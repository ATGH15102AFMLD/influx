// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FXBUNDLE_FX_H_
#define FLATBUFFERS_GENERATED_FXBUNDLE_FX_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 6,
             "Non-compatible flatbuffers version included");

namespace Fx {

struct BundleSignature;
struct BundleSignatureBuilder;
struct BundleSignatureT;

struct TypeField;
struct TypeFieldBuilder;
struct TypeFieldT;

struct TypeLayout;
struct TypeLayoutBuilder;
struct TypeLayoutT;

struct UAVBundle;
struct UAVBundleBuilder;
struct UAVBundleT;

struct GLSLAttribute;
struct GLSLAttributeBuilder;
struct GLSLAttributeT;

struct RoutineBytecodeBundleResources;
struct RoutineBytecodeBundleResourcesBuilder;
struct RoutineBytecodeBundleResourcesT;

struct RoutineBytecodeBundle;
struct RoutineBytecodeBundleBuilder;
struct RoutineBytecodeBundleT;

struct RoutineGLSLBundle;
struct RoutineGLSLBundleBuilder;
struct RoutineGLSLBundleT;

struct PartRenderPass;
struct PartRenderPassBuilder;
struct PartRenderPassT;

struct PartBundle;
struct PartBundleBuilder;
struct PartBundleT;

struct Bundle;
struct BundleBuilder;
struct BundleT;

struct BundleCollection;
struct BundleCollectionBuilder;
struct BundleCollectionT;

enum RoutineBundle : uint8_t {
  RoutineBundle_NONE = 0,
  RoutineBundle_RoutineBytecodeBundle = 1,
  RoutineBundle_RoutineGLSLBundle = 2,
  RoutineBundle_MIN = RoutineBundle_NONE,
  RoutineBundle_MAX = RoutineBundle_RoutineGLSLBundle
};

inline const RoutineBundle (&EnumValuesRoutineBundle())[3] {
  static const RoutineBundle values[] = {
    RoutineBundle_NONE,
    RoutineBundle_RoutineBytecodeBundle,
    RoutineBundle_RoutineGLSLBundle
  };
  return values;
}

inline const char * const *EnumNamesRoutineBundle() {
  static const char * const names[4] = {
    "NONE",
    "RoutineBytecodeBundle",
    "RoutineGLSLBundle",
    nullptr
  };
  return names;
}

inline const char *EnumNameRoutineBundle(RoutineBundle e) {
  if (flatbuffers::IsOutRange(e, RoutineBundle_NONE, RoutineBundle_RoutineGLSLBundle)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRoutineBundle()[index];
}

template<typename T> struct RoutineBundleTraits {
  static const RoutineBundle enum_value = RoutineBundle_NONE;
};

template<> struct RoutineBundleTraits<Fx::RoutineBytecodeBundle> {
  static const RoutineBundle enum_value = RoutineBundle_RoutineBytecodeBundle;
};

template<> struct RoutineBundleTraits<Fx::RoutineGLSLBundle> {
  static const RoutineBundle enum_value = RoutineBundle_RoutineGLSLBundle;
};

template<typename T> struct RoutineBundleUnionTraits {
  static const RoutineBundle enum_value = RoutineBundle_NONE;
};

template<> struct RoutineBundleUnionTraits<Fx::RoutineBytecodeBundleT> {
  static const RoutineBundle enum_value = RoutineBundle_RoutineBytecodeBundle;
};

template<> struct RoutineBundleUnionTraits<Fx::RoutineGLSLBundleT> {
  static const RoutineBundle enum_value = RoutineBundle_RoutineGLSLBundle;
};

struct RoutineBundleUnion {
  RoutineBundle type;
  void *value;

  RoutineBundleUnion() : type(RoutineBundle_NONE), value(nullptr) {}
  RoutineBundleUnion(RoutineBundleUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(RoutineBundle_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  RoutineBundleUnion(const RoutineBundleUnion &);
  RoutineBundleUnion &operator=(const RoutineBundleUnion &u)
    { RoutineBundleUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  RoutineBundleUnion &operator=(RoutineBundleUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~RoutineBundleUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = RoutineBundleUnionTraits<RT>::enum_value;
    if (type != RoutineBundle_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, RoutineBundle type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  Fx::RoutineBytecodeBundleT *AsRoutineBytecodeBundle() {
    return type == RoutineBundle_RoutineBytecodeBundle ?
      reinterpret_cast<Fx::RoutineBytecodeBundleT *>(value) : nullptr;
  }
  const Fx::RoutineBytecodeBundleT *AsRoutineBytecodeBundle() const {
    return type == RoutineBundle_RoutineBytecodeBundle ?
      reinterpret_cast<const Fx::RoutineBytecodeBundleT *>(value) : nullptr;
  }
  Fx::RoutineGLSLBundleT *AsRoutineGLSLBundle() {
    return type == RoutineBundle_RoutineGLSLBundle ?
      reinterpret_cast<Fx::RoutineGLSLBundleT *>(value) : nullptr;
  }
  const Fx::RoutineGLSLBundleT *AsRoutineGLSLBundle() const {
    return type == RoutineBundle_RoutineGLSLBundle ?
      reinterpret_cast<const Fx::RoutineGLSLBundleT *>(value) : nullptr;
  }
};

bool VerifyRoutineBundle(flatbuffers::Verifier &verifier, const void *obj, RoutineBundle type);
bool VerifyRoutineBundleVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum EPartSimRoutines : int16_t {
  EPartSimRoutines_k_Reset = 0,
  EPartSimRoutines_k_Spawn = 1,
  EPartSimRoutines_k_Init = 2,
  EPartSimRoutines_k_Update = 3,
  EPartSimRoutines_k_Last = 4,
  EPartSimRoutines_MIN = EPartSimRoutines_k_Reset,
  EPartSimRoutines_MAX = EPartSimRoutines_k_Last
};

inline const EPartSimRoutines (&EnumValuesEPartSimRoutines())[5] {
  static const EPartSimRoutines values[] = {
    EPartSimRoutines_k_Reset,
    EPartSimRoutines_k_Spawn,
    EPartSimRoutines_k_Init,
    EPartSimRoutines_k_Update,
    EPartSimRoutines_k_Last
  };
  return values;
}

inline const char * const *EnumNamesEPartSimRoutines() {
  static const char * const names[6] = {
    "k_Reset",
    "k_Spawn",
    "k_Init",
    "k_Update",
    "k_Last",
    nullptr
  };
  return names;
}

inline const char *EnumNameEPartSimRoutines(EPartSimRoutines e) {
  if (flatbuffers::IsOutRange(e, EPartSimRoutines_k_Reset, EPartSimRoutines_k_Last)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEPartSimRoutines()[index];
}

enum EPartRenderRoutines : int16_t {
  EPartRenderRoutines_k_Prerender = 0,
  EPartRenderRoutines_k_Vertex = 1,
  EPartRenderRoutines_k_Pixel = 2,
  EPartRenderRoutines_k_Last = 3,
  EPartRenderRoutines_MIN = EPartRenderRoutines_k_Prerender,
  EPartRenderRoutines_MAX = EPartRenderRoutines_k_Last
};

inline const EPartRenderRoutines (&EnumValuesEPartRenderRoutines())[4] {
  static const EPartRenderRoutines values[] = {
    EPartRenderRoutines_k_Prerender,
    EPartRenderRoutines_k_Vertex,
    EPartRenderRoutines_k_Pixel,
    EPartRenderRoutines_k_Last
  };
  return values;
}

inline const char * const *EnumNamesEPartRenderRoutines() {
  static const char * const names[5] = {
    "k_Prerender",
    "k_Vertex",
    "k_Pixel",
    "k_Last",
    nullptr
  };
  return names;
}

inline const char *EnumNameEPartRenderRoutines(EPartRenderRoutines e) {
  if (flatbuffers::IsOutRange(e, EPartRenderRoutines_k_Prerender, EPartRenderRoutines_k_Last)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEPartRenderRoutines()[index];
}

enum BundleContent : uint8_t {
  BundleContent_NONE = 0,
  BundleContent_PartBundle = 1,
  BundleContent_MIN = BundleContent_NONE,
  BundleContent_MAX = BundleContent_PartBundle
};

inline const BundleContent (&EnumValuesBundleContent())[2] {
  static const BundleContent values[] = {
    BundleContent_NONE,
    BundleContent_PartBundle
  };
  return values;
}

inline const char * const *EnumNamesBundleContent() {
  static const char * const names[3] = {
    "NONE",
    "PartBundle",
    nullptr
  };
  return names;
}

inline const char *EnumNameBundleContent(BundleContent e) {
  if (flatbuffers::IsOutRange(e, BundleContent_NONE, BundleContent_PartBundle)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBundleContent()[index];
}

template<typename T> struct BundleContentTraits {
  static const BundleContent enum_value = BundleContent_NONE;
};

template<> struct BundleContentTraits<Fx::PartBundle> {
  static const BundleContent enum_value = BundleContent_PartBundle;
};

template<typename T> struct BundleContentUnionTraits {
  static const BundleContent enum_value = BundleContent_NONE;
};

template<> struct BundleContentUnionTraits<Fx::PartBundleT> {
  static const BundleContent enum_value = BundleContent_PartBundle;
};

struct BundleContentUnion {
  BundleContent type;
  void *value;

  BundleContentUnion() : type(BundleContent_NONE), value(nullptr) {}
  BundleContentUnion(BundleContentUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(BundleContent_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  BundleContentUnion(const BundleContentUnion &);
  BundleContentUnion &operator=(const BundleContentUnion &u)
    { BundleContentUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  BundleContentUnion &operator=(BundleContentUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~BundleContentUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = BundleContentUnionTraits<RT>::enum_value;
    if (type != BundleContent_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, BundleContent type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  Fx::PartBundleT *AsPartBundle() {
    return type == BundleContent_PartBundle ?
      reinterpret_cast<Fx::PartBundleT *>(value) : nullptr;
  }
  const Fx::PartBundleT *AsPartBundle() const {
    return type == BundleContent_PartBundle ?
      reinterpret_cast<const Fx::PartBundleT *>(value) : nullptr;
  }
};

bool VerifyBundleContent(flatbuffers::Verifier &verifier, const void *obj, BundleContent type);
bool VerifyBundleContentVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct BundleSignatureT : public flatbuffers::NativeTable {
  typedef BundleSignature TableType;
  std::string mode{};
  std::string version{};
  std::string commithash{};
  std::string branch{};
  std::string timestamp{};
};

struct BundleSignature FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BundleSignatureT NativeTableType;
  typedef BundleSignatureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4,
    VT_VERSION = 6,
    VT_COMMITHASH = 8,
    VT_BRANCH = 10,
    VT_TIMESTAMP = 12
  };
  const flatbuffers::String *mode() const {
    return GetPointer<const flatbuffers::String *>(VT_MODE);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::String *commithash() const {
    return GetPointer<const flatbuffers::String *>(VT_COMMITHASH);
  }
  const flatbuffers::String *branch() const {
    return GetPointer<const flatbuffers::String *>(VT_BRANCH);
  }
  const flatbuffers::String *timestamp() const {
    return GetPointer<const flatbuffers::String *>(VT_TIMESTAMP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MODE) &&
           verifier.VerifyString(mode()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyOffset(verifier, VT_COMMITHASH) &&
           verifier.VerifyString(commithash()) &&
           VerifyOffset(verifier, VT_BRANCH) &&
           verifier.VerifyString(branch()) &&
           VerifyOffset(verifier, VT_TIMESTAMP) &&
           verifier.VerifyString(timestamp()) &&
           verifier.EndTable();
  }
  BundleSignatureT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BundleSignatureT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BundleSignature> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BundleSignatureT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BundleSignatureBuilder {
  typedef BundleSignature Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(flatbuffers::Offset<flatbuffers::String> mode) {
    fbb_.AddOffset(BundleSignature::VT_MODE, mode);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(BundleSignature::VT_VERSION, version);
  }
  void add_commithash(flatbuffers::Offset<flatbuffers::String> commithash) {
    fbb_.AddOffset(BundleSignature::VT_COMMITHASH, commithash);
  }
  void add_branch(flatbuffers::Offset<flatbuffers::String> branch) {
    fbb_.AddOffset(BundleSignature::VT_BRANCH, branch);
  }
  void add_timestamp(flatbuffers::Offset<flatbuffers::String> timestamp) {
    fbb_.AddOffset(BundleSignature::VT_TIMESTAMP, timestamp);
  }
  explicit BundleSignatureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BundleSignature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BundleSignature>(end);
    return o;
  }
};

inline flatbuffers::Offset<BundleSignature> CreateBundleSignature(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> mode = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> commithash = 0,
    flatbuffers::Offset<flatbuffers::String> branch = 0,
    flatbuffers::Offset<flatbuffers::String> timestamp = 0) {
  BundleSignatureBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_branch(branch);
  builder_.add_commithash(commithash);
  builder_.add_version(version);
  builder_.add_mode(mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<BundleSignature> CreateBundleSignatureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *mode = nullptr,
    const char *version = nullptr,
    const char *commithash = nullptr,
    const char *branch = nullptr,
    const char *timestamp = nullptr) {
  auto mode__ = mode ? _fbb.CreateString(mode) : 0;
  auto version__ = version ? _fbb.CreateString(version) : 0;
  auto commithash__ = commithash ? _fbb.CreateString(commithash) : 0;
  auto branch__ = branch ? _fbb.CreateString(branch) : 0;
  auto timestamp__ = timestamp ? _fbb.CreateString(timestamp) : 0;
  return Fx::CreateBundleSignature(
      _fbb,
      mode__,
      version__,
      commithash__,
      branch__,
      timestamp__);
}

flatbuffers::Offset<BundleSignature> CreateBundleSignature(flatbuffers::FlatBufferBuilder &_fbb, const BundleSignatureT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TypeFieldT : public flatbuffers::NativeTable {
  typedef TypeField TableType;
  std::unique_ptr<Fx::TypeLayoutT> type{};
  std::string name{};
  uint32_t size = 0;
  uint32_t padding = 0;
  TypeFieldT() = default;
  TypeFieldT(const TypeFieldT &o);
  TypeFieldT(TypeFieldT&&) FLATBUFFERS_NOEXCEPT = default;
  TypeFieldT &operator=(TypeFieldT o) FLATBUFFERS_NOEXCEPT;
};

struct TypeField FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TypeFieldT NativeTableType;
  typedef TypeFieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_NAME = 6,
    VT_SIZE = 8,
    VT_PADDING = 10
  };
  const Fx::TypeLayout *type() const {
    return GetPointer<const Fx::TypeLayout *>(VT_TYPE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  uint32_t padding() const {
    return GetField<uint32_t>(VT_PADDING, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_PADDING, 4) &&
           verifier.EndTable();
  }
  TypeFieldT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TypeFieldT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TypeField> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeFieldT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TypeFieldBuilder {
  typedef TypeField Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<Fx::TypeLayout> type) {
    fbb_.AddOffset(TypeField::VT_TYPE, type);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TypeField::VT_NAME, name);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(TypeField::VT_SIZE, size, 0);
  }
  void add_padding(uint32_t padding) {
    fbb_.AddElement<uint32_t>(TypeField::VT_PADDING, padding, 0);
  }
  explicit TypeFieldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TypeField> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TypeField>(end);
    return o;
  }
};

inline flatbuffers::Offset<TypeField> CreateTypeField(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Fx::TypeLayout> type = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t size = 0,
    uint32_t padding = 0) {
  TypeFieldBuilder builder_(_fbb);
  builder_.add_padding(padding);
  builder_.add_size(size);
  builder_.add_name(name);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<TypeField> CreateTypeFieldDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Fx::TypeLayout> type = 0,
    const char *name = nullptr,
    uint32_t size = 0,
    uint32_t padding = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return Fx::CreateTypeField(
      _fbb,
      type,
      name__,
      size,
      padding);
}

flatbuffers::Offset<TypeField> CreateTypeField(flatbuffers::FlatBufferBuilder &_fbb, const TypeFieldT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TypeLayoutT : public flatbuffers::NativeTable {
  typedef TypeLayout TableType;
  std::vector<std::unique_ptr<Fx::TypeFieldT>> fields{};
  int32_t length = 0;
  std::string name{};
  uint32_t size = 0;
  TypeLayoutT() = default;
  TypeLayoutT(const TypeLayoutT &o);
  TypeLayoutT(TypeLayoutT&&) FLATBUFFERS_NOEXCEPT = default;
  TypeLayoutT &operator=(TypeLayoutT o) FLATBUFFERS_NOEXCEPT;
};

struct TypeLayout FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TypeLayoutT NativeTableType;
  typedef TypeLayoutBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIELDS = 4,
    VT_LENGTH = 6,
    VT_NAME = 8,
    VT_SIZE = 10
  };
  const flatbuffers::Vector<flatbuffers::Offset<Fx::TypeField>> *fields() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::TypeField>> *>(VT_FIELDS);
  }
  int32_t length() const {
    return GetField<int32_t>(VT_LENGTH, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FIELDS) &&
           verifier.VerifyVector(fields()) &&
           verifier.VerifyVectorOfTables(fields()) &&
           VerifyField<int32_t>(verifier, VT_LENGTH, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           verifier.EndTable();
  }
  TypeLayoutT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TypeLayoutT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TypeLayout> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeLayoutT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TypeLayoutBuilder {
  typedef TypeLayout Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fields(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::TypeField>>> fields) {
    fbb_.AddOffset(TypeLayout::VT_FIELDS, fields);
  }
  void add_length(int32_t length) {
    fbb_.AddElement<int32_t>(TypeLayout::VT_LENGTH, length, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TypeLayout::VT_NAME, name);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(TypeLayout::VT_SIZE, size, 0);
  }
  explicit TypeLayoutBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TypeLayout> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TypeLayout>(end);
    return o;
  }
};

inline flatbuffers::Offset<TypeLayout> CreateTypeLayout(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::TypeField>>> fields = 0,
    int32_t length = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t size = 0) {
  TypeLayoutBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_name(name);
  builder_.add_length(length);
  builder_.add_fields(fields);
  return builder_.Finish();
}

inline flatbuffers::Offset<TypeLayout> CreateTypeLayoutDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Fx::TypeField>> *fields = nullptr,
    int32_t length = 0,
    const char *name = nullptr,
    uint32_t size = 0) {
  auto fields__ = fields ? _fbb.CreateVector<flatbuffers::Offset<Fx::TypeField>>(*fields) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return Fx::CreateTypeLayout(
      _fbb,
      fields__,
      length,
      name__,
      size);
}

flatbuffers::Offset<TypeLayout> CreateTypeLayout(flatbuffers::FlatBufferBuilder &_fbb, const TypeLayoutT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UAVBundleT : public flatbuffers::NativeTable {
  typedef UAVBundle TableType;
  std::string name{};
  uint32_t slot = 0;
  uint32_t stride = 0;
  std::unique_ptr<Fx::TypeLayoutT> type{};
  UAVBundleT() = default;
  UAVBundleT(const UAVBundleT &o);
  UAVBundleT(UAVBundleT&&) FLATBUFFERS_NOEXCEPT = default;
  UAVBundleT &operator=(UAVBundleT o) FLATBUFFERS_NOEXCEPT;
};

struct UAVBundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UAVBundleT NativeTableType;
  typedef UAVBundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SLOT = 6,
    VT_STRIDE = 8,
    VT_TYPE = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t slot() const {
    return GetField<uint32_t>(VT_SLOT, 0);
  }
  uint32_t stride() const {
    return GetField<uint32_t>(VT_STRIDE, 0);
  }
  const Fx::TypeLayout *type() const {
    return GetPointer<const Fx::TypeLayout *>(VT_TYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_SLOT, 4) &&
           VerifyField<uint32_t>(verifier, VT_STRIDE, 4) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           verifier.EndTable();
  }
  UAVBundleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UAVBundleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UAVBundle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UAVBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UAVBundleBuilder {
  typedef UAVBundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(UAVBundle::VT_NAME, name);
  }
  void add_slot(uint32_t slot) {
    fbb_.AddElement<uint32_t>(UAVBundle::VT_SLOT, slot, 0);
  }
  void add_stride(uint32_t stride) {
    fbb_.AddElement<uint32_t>(UAVBundle::VT_STRIDE, stride, 0);
  }
  void add_type(flatbuffers::Offset<Fx::TypeLayout> type) {
    fbb_.AddOffset(UAVBundle::VT_TYPE, type);
  }
  explicit UAVBundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UAVBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UAVBundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<UAVBundle> CreateUAVBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t slot = 0,
    uint32_t stride = 0,
    flatbuffers::Offset<Fx::TypeLayout> type = 0) {
  UAVBundleBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_stride(stride);
  builder_.add_slot(slot);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<UAVBundle> CreateUAVBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t slot = 0,
    uint32_t stride = 0,
    flatbuffers::Offset<Fx::TypeLayout> type = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return Fx::CreateUAVBundle(
      _fbb,
      name__,
      slot,
      stride,
      type);
}

flatbuffers::Offset<UAVBundle> CreateUAVBundle(flatbuffers::FlatBufferBuilder &_fbb, const UAVBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GLSLAttributeT : public flatbuffers::NativeTable {
  typedef GLSLAttribute TableType;
  uint32_t size = 0;
  uint32_t offset = 0;
  std::string name{};
};

struct GLSLAttribute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GLSLAttributeT NativeTableType;
  typedef GLSLAttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIZE = 4,
    VT_OFFSET = 6,
    VT_NAME = 8
  };
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  uint32_t offset() const {
    return GetField<uint32_t>(VT_OFFSET, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_OFFSET, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
  GLSLAttributeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GLSLAttributeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GLSLAttribute> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GLSLAttributeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GLSLAttributeBuilder {
  typedef GLSLAttribute Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(GLSLAttribute::VT_SIZE, size, 0);
  }
  void add_offset(uint32_t offset) {
    fbb_.AddElement<uint32_t>(GLSLAttribute::VT_OFFSET, offset, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(GLSLAttribute::VT_NAME, name);
  }
  explicit GLSLAttributeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GLSLAttribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GLSLAttribute>(end);
    return o;
  }
};

inline flatbuffers::Offset<GLSLAttribute> CreateGLSLAttribute(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t size = 0,
    uint32_t offset = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  GLSLAttributeBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_offset(offset);
  builder_.add_size(size);
  return builder_.Finish();
}

inline flatbuffers::Offset<GLSLAttribute> CreateGLSLAttributeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t size = 0,
    uint32_t offset = 0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return Fx::CreateGLSLAttribute(
      _fbb,
      size,
      offset,
      name__);
}

flatbuffers::Offset<GLSLAttribute> CreateGLSLAttribute(flatbuffers::FlatBufferBuilder &_fbb, const GLSLAttributeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RoutineBytecodeBundleResourcesT : public flatbuffers::NativeTable {
  typedef RoutineBytecodeBundleResources TableType;
  std::vector<std::unique_ptr<Fx::UAVBundleT>> uavs{};
  RoutineBytecodeBundleResourcesT() = default;
  RoutineBytecodeBundleResourcesT(const RoutineBytecodeBundleResourcesT &o);
  RoutineBytecodeBundleResourcesT(RoutineBytecodeBundleResourcesT&&) FLATBUFFERS_NOEXCEPT = default;
  RoutineBytecodeBundleResourcesT &operator=(RoutineBytecodeBundleResourcesT o) FLATBUFFERS_NOEXCEPT;
};

struct RoutineBytecodeBundleResources FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RoutineBytecodeBundleResourcesT NativeTableType;
  typedef RoutineBytecodeBundleResourcesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UAVS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Fx::UAVBundle>> *uavs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::UAVBundle>> *>(VT_UAVS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UAVS) &&
           verifier.VerifyVector(uavs()) &&
           verifier.VerifyVectorOfTables(uavs()) &&
           verifier.EndTable();
  }
  RoutineBytecodeBundleResourcesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RoutineBytecodeBundleResourcesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RoutineBytecodeBundleResources> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoutineBytecodeBundleResourcesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RoutineBytecodeBundleResourcesBuilder {
  typedef RoutineBytecodeBundleResources Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uavs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::UAVBundle>>> uavs) {
    fbb_.AddOffset(RoutineBytecodeBundleResources::VT_UAVS, uavs);
  }
  explicit RoutineBytecodeBundleResourcesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RoutineBytecodeBundleResources> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RoutineBytecodeBundleResources>(end);
    return o;
  }
};

inline flatbuffers::Offset<RoutineBytecodeBundleResources> CreateRoutineBytecodeBundleResources(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::UAVBundle>>> uavs = 0) {
  RoutineBytecodeBundleResourcesBuilder builder_(_fbb);
  builder_.add_uavs(uavs);
  return builder_.Finish();
}

inline flatbuffers::Offset<RoutineBytecodeBundleResources> CreateRoutineBytecodeBundleResourcesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Fx::UAVBundle>> *uavs = nullptr) {
  auto uavs__ = uavs ? _fbb.CreateVector<flatbuffers::Offset<Fx::UAVBundle>>(*uavs) : 0;
  return Fx::CreateRoutineBytecodeBundleResources(
      _fbb,
      uavs__);
}

flatbuffers::Offset<RoutineBytecodeBundleResources> CreateRoutineBytecodeBundleResources(flatbuffers::FlatBufferBuilder &_fbb, const RoutineBytecodeBundleResourcesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RoutineBytecodeBundleT : public flatbuffers::NativeTable {
  typedef RoutineBytecodeBundle TableType;
  std::vector<uint8_t> code{};
  std::unique_ptr<Fx::RoutineBytecodeBundleResourcesT> resources{};
  std::vector<uint32_t> numthreads{};
  RoutineBytecodeBundleT() = default;
  RoutineBytecodeBundleT(const RoutineBytecodeBundleT &o);
  RoutineBytecodeBundleT(RoutineBytecodeBundleT&&) FLATBUFFERS_NOEXCEPT = default;
  RoutineBytecodeBundleT &operator=(RoutineBytecodeBundleT o) FLATBUFFERS_NOEXCEPT;
};

struct RoutineBytecodeBundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RoutineBytecodeBundleT NativeTableType;
  typedef RoutineBytecodeBundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_RESOURCES = 6,
    VT_NUMTHREADS = 8
  };
  const flatbuffers::Vector<uint8_t> *code() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CODE);
  }
  const Fx::RoutineBytecodeBundleResources *resources() const {
    return GetPointer<const Fx::RoutineBytecodeBundleResources *>(VT_RESOURCES);
  }
  const flatbuffers::Vector<uint32_t> *numthreads() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_NUMTHREADS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CODE) &&
           verifier.VerifyVector(code()) &&
           VerifyOffset(verifier, VT_RESOURCES) &&
           verifier.VerifyTable(resources()) &&
           VerifyOffset(verifier, VT_NUMTHREADS) &&
           verifier.VerifyVector(numthreads()) &&
           verifier.EndTable();
  }
  RoutineBytecodeBundleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RoutineBytecodeBundleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RoutineBytecodeBundle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoutineBytecodeBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RoutineBytecodeBundleBuilder {
  typedef RoutineBytecodeBundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> code) {
    fbb_.AddOffset(RoutineBytecodeBundle::VT_CODE, code);
  }
  void add_resources(flatbuffers::Offset<Fx::RoutineBytecodeBundleResources> resources) {
    fbb_.AddOffset(RoutineBytecodeBundle::VT_RESOURCES, resources);
  }
  void add_numthreads(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> numthreads) {
    fbb_.AddOffset(RoutineBytecodeBundle::VT_NUMTHREADS, numthreads);
  }
  explicit RoutineBytecodeBundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RoutineBytecodeBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RoutineBytecodeBundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<RoutineBytecodeBundle> CreateRoutineBytecodeBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> code = 0,
    flatbuffers::Offset<Fx::RoutineBytecodeBundleResources> resources = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> numthreads = 0) {
  RoutineBytecodeBundleBuilder builder_(_fbb);
  builder_.add_numthreads(numthreads);
  builder_.add_resources(resources);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<RoutineBytecodeBundle> CreateRoutineBytecodeBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *code = nullptr,
    flatbuffers::Offset<Fx::RoutineBytecodeBundleResources> resources = 0,
    const std::vector<uint32_t> *numthreads = nullptr) {
  auto code__ = code ? _fbb.CreateVector<uint8_t>(*code) : 0;
  auto numthreads__ = numthreads ? _fbb.CreateVector<uint32_t>(*numthreads) : 0;
  return Fx::CreateRoutineBytecodeBundle(
      _fbb,
      code__,
      resources,
      numthreads__);
}

flatbuffers::Offset<RoutineBytecodeBundle> CreateRoutineBytecodeBundle(flatbuffers::FlatBufferBuilder &_fbb, const RoutineBytecodeBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RoutineGLSLBundleT : public flatbuffers::NativeTable {
  typedef RoutineGLSLBundle TableType;
  std::string code{};
  std::vector<std::unique_ptr<Fx::GLSLAttributeT>> attributes{};
  RoutineGLSLBundleT() = default;
  RoutineGLSLBundleT(const RoutineGLSLBundleT &o);
  RoutineGLSLBundleT(RoutineGLSLBundleT&&) FLATBUFFERS_NOEXCEPT = default;
  RoutineGLSLBundleT &operator=(RoutineGLSLBundleT o) FLATBUFFERS_NOEXCEPT;
};

struct RoutineGLSLBundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RoutineGLSLBundleT NativeTableType;
  typedef RoutineGLSLBundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_ATTRIBUTES = 6
  };
  const flatbuffers::String *code() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Fx::GLSLAttribute>> *attributes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::GLSLAttribute>> *>(VT_ATTRIBUTES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CODE) &&
           verifier.VerifyString(code()) &&
           VerifyOffset(verifier, VT_ATTRIBUTES) &&
           verifier.VerifyVector(attributes()) &&
           verifier.VerifyVectorOfTables(attributes()) &&
           verifier.EndTable();
  }
  RoutineGLSLBundleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RoutineGLSLBundleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RoutineGLSLBundle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoutineGLSLBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RoutineGLSLBundleBuilder {
  typedef RoutineGLSLBundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(flatbuffers::Offset<flatbuffers::String> code) {
    fbb_.AddOffset(RoutineGLSLBundle::VT_CODE, code);
  }
  void add_attributes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::GLSLAttribute>>> attributes) {
    fbb_.AddOffset(RoutineGLSLBundle::VT_ATTRIBUTES, attributes);
  }
  explicit RoutineGLSLBundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RoutineGLSLBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RoutineGLSLBundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<RoutineGLSLBundle> CreateRoutineGLSLBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> code = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::GLSLAttribute>>> attributes = 0) {
  RoutineGLSLBundleBuilder builder_(_fbb);
  builder_.add_attributes(attributes);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<RoutineGLSLBundle> CreateRoutineGLSLBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *code = nullptr,
    const std::vector<flatbuffers::Offset<Fx::GLSLAttribute>> *attributes = nullptr) {
  auto code__ = code ? _fbb.CreateString(code) : 0;
  auto attributes__ = attributes ? _fbb.CreateVector<flatbuffers::Offset<Fx::GLSLAttribute>>(*attributes) : 0;
  return Fx::CreateRoutineGLSLBundle(
      _fbb,
      code__,
      attributes__);
}

flatbuffers::Offset<RoutineGLSLBundle> CreateRoutineGLSLBundle(flatbuffers::FlatBufferBuilder &_fbb, const RoutineGLSLBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PartRenderPassT : public flatbuffers::NativeTable {
  typedef PartRenderPass TableType;
  std::vector<Fx::RoutineBundleUnion> routines{};
  std::string geometry{};
  bool sorting = false;
  uint32_t instanceCount = 0;
  uint32_t stride = 0;
  std::unique_ptr<Fx::TypeLayoutT> instance{};
  PartRenderPassT() = default;
  PartRenderPassT(const PartRenderPassT &o);
  PartRenderPassT(PartRenderPassT&&) FLATBUFFERS_NOEXCEPT = default;
  PartRenderPassT &operator=(PartRenderPassT o) FLATBUFFERS_NOEXCEPT;
};

struct PartRenderPass FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PartRenderPassT NativeTableType;
  typedef PartRenderPassBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROUTINES_TYPE = 4,
    VT_ROUTINES = 6,
    VT_GEOMETRY = 8,
    VT_SORTING = 10,
    VT_INSTANCECOUNT = 12,
    VT_STRIDE = 14,
    VT_INSTANCE = 16
  };
  const flatbuffers::Vector<uint8_t> *routines_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ROUTINES_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *routines() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_ROUTINES);
  }
  const flatbuffers::String *geometry() const {
    return GetPointer<const flatbuffers::String *>(VT_GEOMETRY);
  }
  bool sorting() const {
    return GetField<uint8_t>(VT_SORTING, 0) != 0;
  }
  uint32_t instanceCount() const {
    return GetField<uint32_t>(VT_INSTANCECOUNT, 0);
  }
  uint32_t stride() const {
    return GetField<uint32_t>(VT_STRIDE, 0);
  }
  const Fx::TypeLayout *instance() const {
    return GetPointer<const Fx::TypeLayout *>(VT_INSTANCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROUTINES_TYPE) &&
           verifier.VerifyVector(routines_type()) &&
           VerifyOffset(verifier, VT_ROUTINES) &&
           verifier.VerifyVector(routines()) &&
           VerifyRoutineBundleVector(verifier, routines(), routines_type()) &&
           VerifyOffset(verifier, VT_GEOMETRY) &&
           verifier.VerifyString(geometry()) &&
           VerifyField<uint8_t>(verifier, VT_SORTING, 1) &&
           VerifyField<uint32_t>(verifier, VT_INSTANCECOUNT, 4) &&
           VerifyField<uint32_t>(verifier, VT_STRIDE, 4) &&
           VerifyOffset(verifier, VT_INSTANCE) &&
           verifier.VerifyTable(instance()) &&
           verifier.EndTable();
  }
  PartRenderPassT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PartRenderPassT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PartRenderPass> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartRenderPassT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PartRenderPassBuilder {
  typedef PartRenderPass Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_routines_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> routines_type) {
    fbb_.AddOffset(PartRenderPass::VT_ROUTINES_TYPE, routines_type);
  }
  void add_routines(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> routines) {
    fbb_.AddOffset(PartRenderPass::VT_ROUTINES, routines);
  }
  void add_geometry(flatbuffers::Offset<flatbuffers::String> geometry) {
    fbb_.AddOffset(PartRenderPass::VT_GEOMETRY, geometry);
  }
  void add_sorting(bool sorting) {
    fbb_.AddElement<uint8_t>(PartRenderPass::VT_SORTING, static_cast<uint8_t>(sorting), 0);
  }
  void add_instanceCount(uint32_t instanceCount) {
    fbb_.AddElement<uint32_t>(PartRenderPass::VT_INSTANCECOUNT, instanceCount, 0);
  }
  void add_stride(uint32_t stride) {
    fbb_.AddElement<uint32_t>(PartRenderPass::VT_STRIDE, stride, 0);
  }
  void add_instance(flatbuffers::Offset<Fx::TypeLayout> instance) {
    fbb_.AddOffset(PartRenderPass::VT_INSTANCE, instance);
  }
  explicit PartRenderPassBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PartRenderPass> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PartRenderPass>(end);
    return o;
  }
};

inline flatbuffers::Offset<PartRenderPass> CreatePartRenderPass(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> routines_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> routines = 0,
    flatbuffers::Offset<flatbuffers::String> geometry = 0,
    bool sorting = false,
    uint32_t instanceCount = 0,
    uint32_t stride = 0,
    flatbuffers::Offset<Fx::TypeLayout> instance = 0) {
  PartRenderPassBuilder builder_(_fbb);
  builder_.add_instance(instance);
  builder_.add_stride(stride);
  builder_.add_instanceCount(instanceCount);
  builder_.add_geometry(geometry);
  builder_.add_routines(routines);
  builder_.add_routines_type(routines_type);
  builder_.add_sorting(sorting);
  return builder_.Finish();
}

inline flatbuffers::Offset<PartRenderPass> CreatePartRenderPassDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *routines_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *routines = nullptr,
    const char *geometry = nullptr,
    bool sorting = false,
    uint32_t instanceCount = 0,
    uint32_t stride = 0,
    flatbuffers::Offset<Fx::TypeLayout> instance = 0) {
  auto routines_type__ = routines_type ? _fbb.CreateVector<uint8_t>(*routines_type) : 0;
  auto routines__ = routines ? _fbb.CreateVector<flatbuffers::Offset<void>>(*routines) : 0;
  auto geometry__ = geometry ? _fbb.CreateString(geometry) : 0;
  return Fx::CreatePartRenderPass(
      _fbb,
      routines_type__,
      routines__,
      geometry__,
      sorting,
      instanceCount,
      stride,
      instance);
}

flatbuffers::Offset<PartRenderPass> CreatePartRenderPass(flatbuffers::FlatBufferBuilder &_fbb, const PartRenderPassT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PartBundleT : public flatbuffers::NativeTable {
  typedef PartBundle TableType;
  uint32_t capacity = 0;
  std::vector<Fx::RoutineBundleUnion> simulationRoutines{};
  std::vector<std::unique_ptr<Fx::PartRenderPassT>> renderPasses{};
  std::unique_ptr<Fx::TypeLayoutT> particle{};
  PartBundleT() = default;
  PartBundleT(const PartBundleT &o);
  PartBundleT(PartBundleT&&) FLATBUFFERS_NOEXCEPT = default;
  PartBundleT &operator=(PartBundleT o) FLATBUFFERS_NOEXCEPT;
};

struct PartBundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PartBundleT NativeTableType;
  typedef PartBundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CAPACITY = 4,
    VT_SIMULATIONROUTINES_TYPE = 6,
    VT_SIMULATIONROUTINES = 8,
    VT_RENDERPASSES = 10,
    VT_PARTICLE = 12
  };
  uint32_t capacity() const {
    return GetField<uint32_t>(VT_CAPACITY, 0);
  }
  const flatbuffers::Vector<uint8_t> *simulationRoutines_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SIMULATIONROUTINES_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *simulationRoutines() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_SIMULATIONROUTINES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Fx::PartRenderPass>> *renderPasses() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::PartRenderPass>> *>(VT_RENDERPASSES);
  }
  const Fx::TypeLayout *particle() const {
    return GetPointer<const Fx::TypeLayout *>(VT_PARTICLE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CAPACITY, 4) &&
           VerifyOffset(verifier, VT_SIMULATIONROUTINES_TYPE) &&
           verifier.VerifyVector(simulationRoutines_type()) &&
           VerifyOffset(verifier, VT_SIMULATIONROUTINES) &&
           verifier.VerifyVector(simulationRoutines()) &&
           VerifyRoutineBundleVector(verifier, simulationRoutines(), simulationRoutines_type()) &&
           VerifyOffset(verifier, VT_RENDERPASSES) &&
           verifier.VerifyVector(renderPasses()) &&
           verifier.VerifyVectorOfTables(renderPasses()) &&
           VerifyOffset(verifier, VT_PARTICLE) &&
           verifier.VerifyTable(particle()) &&
           verifier.EndTable();
  }
  PartBundleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PartBundleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PartBundle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PartBundleBuilder {
  typedef PartBundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_capacity(uint32_t capacity) {
    fbb_.AddElement<uint32_t>(PartBundle::VT_CAPACITY, capacity, 0);
  }
  void add_simulationRoutines_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> simulationRoutines_type) {
    fbb_.AddOffset(PartBundle::VT_SIMULATIONROUTINES_TYPE, simulationRoutines_type);
  }
  void add_simulationRoutines(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> simulationRoutines) {
    fbb_.AddOffset(PartBundle::VT_SIMULATIONROUTINES, simulationRoutines);
  }
  void add_renderPasses(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::PartRenderPass>>> renderPasses) {
    fbb_.AddOffset(PartBundle::VT_RENDERPASSES, renderPasses);
  }
  void add_particle(flatbuffers::Offset<Fx::TypeLayout> particle) {
    fbb_.AddOffset(PartBundle::VT_PARTICLE, particle);
  }
  explicit PartBundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PartBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PartBundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<PartBundle> CreatePartBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t capacity = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> simulationRoutines_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> simulationRoutines = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::PartRenderPass>>> renderPasses = 0,
    flatbuffers::Offset<Fx::TypeLayout> particle = 0) {
  PartBundleBuilder builder_(_fbb);
  builder_.add_particle(particle);
  builder_.add_renderPasses(renderPasses);
  builder_.add_simulationRoutines(simulationRoutines);
  builder_.add_simulationRoutines_type(simulationRoutines_type);
  builder_.add_capacity(capacity);
  return builder_.Finish();
}

inline flatbuffers::Offset<PartBundle> CreatePartBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t capacity = 0,
    const std::vector<uint8_t> *simulationRoutines_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *simulationRoutines = nullptr,
    const std::vector<flatbuffers::Offset<Fx::PartRenderPass>> *renderPasses = nullptr,
    flatbuffers::Offset<Fx::TypeLayout> particle = 0) {
  auto simulationRoutines_type__ = simulationRoutines_type ? _fbb.CreateVector<uint8_t>(*simulationRoutines_type) : 0;
  auto simulationRoutines__ = simulationRoutines ? _fbb.CreateVector<flatbuffers::Offset<void>>(*simulationRoutines) : 0;
  auto renderPasses__ = renderPasses ? _fbb.CreateVector<flatbuffers::Offset<Fx::PartRenderPass>>(*renderPasses) : 0;
  return Fx::CreatePartBundle(
      _fbb,
      capacity,
      simulationRoutines_type__,
      simulationRoutines__,
      renderPasses__,
      particle);
}

flatbuffers::Offset<PartBundle> CreatePartBundle(flatbuffers::FlatBufferBuilder &_fbb, const PartBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BundleT : public flatbuffers::NativeTable {
  typedef Bundle TableType;
  std::string name{};
  std::unique_ptr<Fx::BundleSignatureT> signature{};
  Fx::BundleContentUnion content{};
  BundleT() = default;
  BundleT(const BundleT &o);
  BundleT(BundleT&&) FLATBUFFERS_NOEXCEPT = default;
  BundleT &operator=(BundleT o) FLATBUFFERS_NOEXCEPT;
};

struct Bundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BundleT NativeTableType;
  typedef BundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SIGNATURE = 6,
    VT_CONTENT_TYPE = 8,
    VT_CONTENT = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const Fx::BundleSignature *signature() const {
    return GetPointer<const Fx::BundleSignature *>(VT_SIGNATURE);
  }
  Fx::BundleContent content_type() const {
    return static_cast<Fx::BundleContent>(GetField<uint8_t>(VT_CONTENT_TYPE, 0));
  }
  const void *content() const {
    return GetPointer<const void *>(VT_CONTENT);
  }
  template<typename T> const T *content_as() const;
  const Fx::PartBundle *content_as_PartBundle() const {
    return content_type() == Fx::BundleContent_PartBundle ? static_cast<const Fx::PartBundle *>(content()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyTable(signature()) &&
           VerifyField<uint8_t>(verifier, VT_CONTENT_TYPE, 1) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           VerifyBundleContent(verifier, content(), content_type()) &&
           verifier.EndTable();
  }
  BundleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BundleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Bundle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BundleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const Fx::PartBundle *Bundle::content_as<Fx::PartBundle>() const {
  return content_as_PartBundle();
}

struct BundleBuilder {
  typedef Bundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Bundle::VT_NAME, name);
  }
  void add_signature(flatbuffers::Offset<Fx::BundleSignature> signature) {
    fbb_.AddOffset(Bundle::VT_SIGNATURE, signature);
  }
  void add_content_type(Fx::BundleContent content_type) {
    fbb_.AddElement<uint8_t>(Bundle::VT_CONTENT_TYPE, static_cast<uint8_t>(content_type), 0);
  }
  void add_content(flatbuffers::Offset<void> content) {
    fbb_.AddOffset(Bundle::VT_CONTENT, content);
  }
  explicit BundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Bundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Bundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<Bundle> CreateBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<Fx::BundleSignature> signature = 0,
    Fx::BundleContent content_type = Fx::BundleContent_NONE,
    flatbuffers::Offset<void> content = 0) {
  BundleBuilder builder_(_fbb);
  builder_.add_content(content);
  builder_.add_signature(signature);
  builder_.add_name(name);
  builder_.add_content_type(content_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Bundle> CreateBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<Fx::BundleSignature> signature = 0,
    Fx::BundleContent content_type = Fx::BundleContent_NONE,
    flatbuffers::Offset<void> content = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return Fx::CreateBundle(
      _fbb,
      name__,
      signature,
      content_type,
      content);
}

flatbuffers::Offset<Bundle> CreateBundle(flatbuffers::FlatBufferBuilder &_fbb, const BundleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BundleCollectionT : public flatbuffers::NativeTable {
  typedef BundleCollection TableType;
  std::vector<std::unique_ptr<Fx::BundleT>> content{};
  BundleCollectionT() = default;
  BundleCollectionT(const BundleCollectionT &o);
  BundleCollectionT(BundleCollectionT&&) FLATBUFFERS_NOEXCEPT = default;
  BundleCollectionT &operator=(BundleCollectionT o) FLATBUFFERS_NOEXCEPT;
};

struct BundleCollection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BundleCollectionT NativeTableType;
  typedef BundleCollectionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENT = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Fx::Bundle>> *content() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::Bundle>> *>(VT_CONTENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyVector(content()) &&
           verifier.VerifyVectorOfTables(content()) &&
           verifier.EndTable();
  }
  BundleCollectionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BundleCollectionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BundleCollection> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BundleCollectionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BundleCollectionBuilder {
  typedef BundleCollection Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_content(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::Bundle>>> content) {
    fbb_.AddOffset(BundleCollection::VT_CONTENT, content);
  }
  explicit BundleCollectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BundleCollection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BundleCollection>(end);
    return o;
  }
};

inline flatbuffers::Offset<BundleCollection> CreateBundleCollection(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::Bundle>>> content = 0) {
  BundleCollectionBuilder builder_(_fbb);
  builder_.add_content(content);
  return builder_.Finish();
}

inline flatbuffers::Offset<BundleCollection> CreateBundleCollectionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Fx::Bundle>> *content = nullptr) {
  auto content__ = content ? _fbb.CreateVector<flatbuffers::Offset<Fx::Bundle>>(*content) : 0;
  return Fx::CreateBundleCollection(
      _fbb,
      content__);
}

flatbuffers::Offset<BundleCollection> CreateBundleCollection(flatbuffers::FlatBufferBuilder &_fbb, const BundleCollectionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline BundleSignatureT *BundleSignature::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BundleSignatureT>(new BundleSignatureT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BundleSignature::UnPackTo(BundleSignatureT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = mode(); if (_e) _o->mode = _e->str(); }
  { auto _e = version(); if (_e) _o->version = _e->str(); }
  { auto _e = commithash(); if (_e) _o->commithash = _e->str(); }
  { auto _e = branch(); if (_e) _o->branch = _e->str(); }
  { auto _e = timestamp(); if (_e) _o->timestamp = _e->str(); }
}

inline flatbuffers::Offset<BundleSignature> BundleSignature::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BundleSignatureT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBundleSignature(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BundleSignature> CreateBundleSignature(flatbuffers::FlatBufferBuilder &_fbb, const BundleSignatureT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BundleSignatureT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _mode = _o->mode.empty() ? 0 : _fbb.CreateString(_o->mode);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _commithash = _o->commithash.empty() ? 0 : _fbb.CreateString(_o->commithash);
  auto _branch = _o->branch.empty() ? 0 : _fbb.CreateString(_o->branch);
  auto _timestamp = _o->timestamp.empty() ? 0 : _fbb.CreateString(_o->timestamp);
  return Fx::CreateBundleSignature(
      _fbb,
      _mode,
      _version,
      _commithash,
      _branch,
      _timestamp);
}

inline TypeFieldT::TypeFieldT(const TypeFieldT &o)
      : type((o.type) ? new Fx::TypeLayoutT(*o.type) : nullptr),
        name(o.name),
        size(o.size),
        padding(o.padding) {
}

inline TypeFieldT &TypeFieldT::operator=(TypeFieldT o) FLATBUFFERS_NOEXCEPT {
  std::swap(type, o.type);
  std::swap(name, o.name);
  std::swap(size, o.size);
  std::swap(padding, o.padding);
  return *this;
}

inline TypeFieldT *TypeField::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TypeFieldT>(new TypeFieldT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TypeField::UnPackTo(TypeFieldT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); if (_e) { if(_o->type) { _e->UnPackTo(_o->type.get(), _resolver); } else { _o->type = std::unique_ptr<Fx::TypeLayoutT>(_e->UnPack(_resolver)); } } }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = size(); _o->size = _e; }
  { auto _e = padding(); _o->padding = _e; }
}

inline flatbuffers::Offset<TypeField> TypeField::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeFieldT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTypeField(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TypeField> CreateTypeField(flatbuffers::FlatBufferBuilder &_fbb, const TypeFieldT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TypeFieldT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type ? CreateTypeLayout(_fbb, _o->type.get(), _rehasher) : 0;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _size = _o->size;
  auto _padding = _o->padding;
  return Fx::CreateTypeField(
      _fbb,
      _type,
      _name,
      _size,
      _padding);
}

inline TypeLayoutT::TypeLayoutT(const TypeLayoutT &o)
      : length(o.length),
        name(o.name),
        size(o.size) {
  fields.reserve(o.fields.size());
  for (const auto &fields_ : o.fields) { fields.emplace_back((fields_) ? new Fx::TypeFieldT(*fields_) : nullptr); }
}

inline TypeLayoutT &TypeLayoutT::operator=(TypeLayoutT o) FLATBUFFERS_NOEXCEPT {
  std::swap(fields, o.fields);
  std::swap(length, o.length);
  std::swap(name, o.name);
  std::swap(size, o.size);
  return *this;
}

inline TypeLayoutT *TypeLayout::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TypeLayoutT>(new TypeLayoutT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TypeLayout::UnPackTo(TypeLayoutT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fields(); if (_e) { _o->fields.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->fields[_i]) { _e->Get(_i)->UnPackTo(_o->fields[_i].get(), _resolver); } else { _o->fields[_i] = std::unique_ptr<Fx::TypeFieldT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = length(); _o->length = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = size(); _o->size = _e; }
}

inline flatbuffers::Offset<TypeLayout> TypeLayout::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeLayoutT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTypeLayout(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TypeLayout> CreateTypeLayout(flatbuffers::FlatBufferBuilder &_fbb, const TypeLayoutT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TypeLayoutT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fields = _o->fields.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::TypeField>> (_o->fields.size(), [](size_t i, _VectorArgs *__va) { return CreateTypeField(*__va->__fbb, __va->__o->fields[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _length = _o->length;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _size = _o->size;
  return Fx::CreateTypeLayout(
      _fbb,
      _fields,
      _length,
      _name,
      _size);
}

inline UAVBundleT::UAVBundleT(const UAVBundleT &o)
      : name(o.name),
        slot(o.slot),
        stride(o.stride),
        type((o.type) ? new Fx::TypeLayoutT(*o.type) : nullptr) {
}

inline UAVBundleT &UAVBundleT::operator=(UAVBundleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(name, o.name);
  std::swap(slot, o.slot);
  std::swap(stride, o.stride);
  std::swap(type, o.type);
  return *this;
}

inline UAVBundleT *UAVBundle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UAVBundleT>(new UAVBundleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UAVBundle::UnPackTo(UAVBundleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = slot(); _o->slot = _e; }
  { auto _e = stride(); _o->stride = _e; }
  { auto _e = type(); if (_e) { if(_o->type) { _e->UnPackTo(_o->type.get(), _resolver); } else { _o->type = std::unique_ptr<Fx::TypeLayoutT>(_e->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<UAVBundle> UAVBundle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UAVBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUAVBundle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UAVBundle> CreateUAVBundle(flatbuffers::FlatBufferBuilder &_fbb, const UAVBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UAVBundleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _slot = _o->slot;
  auto _stride = _o->stride;
  auto _type = _o->type ? CreateTypeLayout(_fbb, _o->type.get(), _rehasher) : 0;
  return Fx::CreateUAVBundle(
      _fbb,
      _name,
      _slot,
      _stride,
      _type);
}

inline GLSLAttributeT *GLSLAttribute::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GLSLAttributeT>(new GLSLAttributeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GLSLAttribute::UnPackTo(GLSLAttributeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = size(); _o->size = _e; }
  { auto _e = offset(); _o->offset = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
}

inline flatbuffers::Offset<GLSLAttribute> GLSLAttribute::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GLSLAttributeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGLSLAttribute(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GLSLAttribute> CreateGLSLAttribute(flatbuffers::FlatBufferBuilder &_fbb, const GLSLAttributeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GLSLAttributeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _size = _o->size;
  auto _offset = _o->offset;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  return Fx::CreateGLSLAttribute(
      _fbb,
      _size,
      _offset,
      _name);
}

inline RoutineBytecodeBundleResourcesT::RoutineBytecodeBundleResourcesT(const RoutineBytecodeBundleResourcesT &o) {
  uavs.reserve(o.uavs.size());
  for (const auto &uavs_ : o.uavs) { uavs.emplace_back((uavs_) ? new Fx::UAVBundleT(*uavs_) : nullptr); }
}

inline RoutineBytecodeBundleResourcesT &RoutineBytecodeBundleResourcesT::operator=(RoutineBytecodeBundleResourcesT o) FLATBUFFERS_NOEXCEPT {
  std::swap(uavs, o.uavs);
  return *this;
}

inline RoutineBytecodeBundleResourcesT *RoutineBytecodeBundleResources::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RoutineBytecodeBundleResourcesT>(new RoutineBytecodeBundleResourcesT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RoutineBytecodeBundleResources::UnPackTo(RoutineBytecodeBundleResourcesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uavs(); if (_e) { _o->uavs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->uavs[_i]) { _e->Get(_i)->UnPackTo(_o->uavs[_i].get(), _resolver); } else { _o->uavs[_i] = std::unique_ptr<Fx::UAVBundleT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<RoutineBytecodeBundleResources> RoutineBytecodeBundleResources::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoutineBytecodeBundleResourcesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRoutineBytecodeBundleResources(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RoutineBytecodeBundleResources> CreateRoutineBytecodeBundleResources(flatbuffers::FlatBufferBuilder &_fbb, const RoutineBytecodeBundleResourcesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RoutineBytecodeBundleResourcesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _uavs = _o->uavs.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::UAVBundle>> (_o->uavs.size(), [](size_t i, _VectorArgs *__va) { return CreateUAVBundle(*__va->__fbb, __va->__o->uavs[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Fx::CreateRoutineBytecodeBundleResources(
      _fbb,
      _uavs);
}

inline RoutineBytecodeBundleT::RoutineBytecodeBundleT(const RoutineBytecodeBundleT &o)
      : code(o.code),
        resources((o.resources) ? new Fx::RoutineBytecodeBundleResourcesT(*o.resources) : nullptr),
        numthreads(o.numthreads) {
}

inline RoutineBytecodeBundleT &RoutineBytecodeBundleT::operator=(RoutineBytecodeBundleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(code, o.code);
  std::swap(resources, o.resources);
  std::swap(numthreads, o.numthreads);
  return *this;
}

inline RoutineBytecodeBundleT *RoutineBytecodeBundle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RoutineBytecodeBundleT>(new RoutineBytecodeBundleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RoutineBytecodeBundle::UnPackTo(RoutineBytecodeBundleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = code(); if (_e) { _o->code.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->code.begin()); } }
  { auto _e = resources(); if (_e) { if(_o->resources) { _e->UnPackTo(_o->resources.get(), _resolver); } else { _o->resources = std::unique_ptr<Fx::RoutineBytecodeBundleResourcesT>(_e->UnPack(_resolver)); } } }
  { auto _e = numthreads(); if (_e) { _o->numthreads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->numthreads[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<RoutineBytecodeBundle> RoutineBytecodeBundle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoutineBytecodeBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRoutineBytecodeBundle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RoutineBytecodeBundle> CreateRoutineBytecodeBundle(flatbuffers::FlatBufferBuilder &_fbb, const RoutineBytecodeBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RoutineBytecodeBundleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _code = _o->code.size() ? _fbb.CreateVector(_o->code) : 0;
  auto _resources = _o->resources ? CreateRoutineBytecodeBundleResources(_fbb, _o->resources.get(), _rehasher) : 0;
  auto _numthreads = _o->numthreads.size() ? _fbb.CreateVector(_o->numthreads) : 0;
  return Fx::CreateRoutineBytecodeBundle(
      _fbb,
      _code,
      _resources,
      _numthreads);
}

inline RoutineGLSLBundleT::RoutineGLSLBundleT(const RoutineGLSLBundleT &o)
      : code(o.code) {
  attributes.reserve(o.attributes.size());
  for (const auto &attributes_ : o.attributes) { attributes.emplace_back((attributes_) ? new Fx::GLSLAttributeT(*attributes_) : nullptr); }
}

inline RoutineGLSLBundleT &RoutineGLSLBundleT::operator=(RoutineGLSLBundleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(code, o.code);
  std::swap(attributes, o.attributes);
  return *this;
}

inline RoutineGLSLBundleT *RoutineGLSLBundle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RoutineGLSLBundleT>(new RoutineGLSLBundleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RoutineGLSLBundle::UnPackTo(RoutineGLSLBundleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = code(); if (_e) _o->code = _e->str(); }
  { auto _e = attributes(); if (_e) { _o->attributes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->attributes[_i]) { _e->Get(_i)->UnPackTo(_o->attributes[_i].get(), _resolver); } else { _o->attributes[_i] = std::unique_ptr<Fx::GLSLAttributeT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<RoutineGLSLBundle> RoutineGLSLBundle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoutineGLSLBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRoutineGLSLBundle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RoutineGLSLBundle> CreateRoutineGLSLBundle(flatbuffers::FlatBufferBuilder &_fbb, const RoutineGLSLBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RoutineGLSLBundleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _code = _o->code.empty() ? 0 : _fbb.CreateString(_o->code);
  auto _attributes = _o->attributes.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::GLSLAttribute>> (_o->attributes.size(), [](size_t i, _VectorArgs *__va) { return CreateGLSLAttribute(*__va->__fbb, __va->__o->attributes[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Fx::CreateRoutineGLSLBundle(
      _fbb,
      _code,
      _attributes);
}

inline PartRenderPassT::PartRenderPassT(const PartRenderPassT &o)
      : routines(o.routines),
        geometry(o.geometry),
        sorting(o.sorting),
        instanceCount(o.instanceCount),
        stride(o.stride),
        instance((o.instance) ? new Fx::TypeLayoutT(*o.instance) : nullptr) {
}

inline PartRenderPassT &PartRenderPassT::operator=(PartRenderPassT o) FLATBUFFERS_NOEXCEPT {
  std::swap(routines, o.routines);
  std::swap(geometry, o.geometry);
  std::swap(sorting, o.sorting);
  std::swap(instanceCount, o.instanceCount);
  std::swap(stride, o.stride);
  std::swap(instance, o.instance);
  return *this;
}

inline PartRenderPassT *PartRenderPass::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PartRenderPassT>(new PartRenderPassT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PartRenderPass::UnPackTo(PartRenderPassT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = routines_type(); if (_e) { _o->routines.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->routines[_i].type = static_cast<Fx::RoutineBundle>(_e->Get(_i)); } } }
  { auto _e = routines(); if (_e) { _o->routines.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->routines[_i].value = Fx::RoutineBundleUnion::UnPack(_e->Get(_i), routines_type()->GetEnum<RoutineBundle>(_i), _resolver); } } }
  { auto _e = geometry(); if (_e) _o->geometry = _e->str(); }
  { auto _e = sorting(); _o->sorting = _e; }
  { auto _e = instanceCount(); _o->instanceCount = _e; }
  { auto _e = stride(); _o->stride = _e; }
  { auto _e = instance(); if (_e) { if(_o->instance) { _e->UnPackTo(_o->instance.get(), _resolver); } else { _o->instance = std::unique_ptr<Fx::TypeLayoutT>(_e->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<PartRenderPass> PartRenderPass::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartRenderPassT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePartRenderPass(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PartRenderPass> CreatePartRenderPass(flatbuffers::FlatBufferBuilder &_fbb, const PartRenderPassT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PartRenderPassT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _routines_type = _o->routines.size() ? _fbb.CreateVector<uint8_t>(_o->routines.size(), [](size_t i, _VectorArgs *__va) { return static_cast<uint8_t>(__va->__o->routines[i].type); }, &_va) : 0;
  auto _routines = _o->routines.size() ? _fbb.CreateVector<flatbuffers::Offset<void>>(_o->routines.size(), [](size_t i, _VectorArgs *__va) { return __va->__o->routines[i].Pack(*__va->__fbb, __va->__rehasher); }, &_va) : 0;
  auto _geometry = _o->geometry.empty() ? 0 : _fbb.CreateString(_o->geometry);
  auto _sorting = _o->sorting;
  auto _instanceCount = _o->instanceCount;
  auto _stride = _o->stride;
  auto _instance = _o->instance ? CreateTypeLayout(_fbb, _o->instance.get(), _rehasher) : 0;
  return Fx::CreatePartRenderPass(
      _fbb,
      _routines_type,
      _routines,
      _geometry,
      _sorting,
      _instanceCount,
      _stride,
      _instance);
}

inline PartBundleT::PartBundleT(const PartBundleT &o)
      : capacity(o.capacity),
        simulationRoutines(o.simulationRoutines),
        particle((o.particle) ? new Fx::TypeLayoutT(*o.particle) : nullptr) {
  renderPasses.reserve(o.renderPasses.size());
  for (const auto &renderPasses_ : o.renderPasses) { renderPasses.emplace_back((renderPasses_) ? new Fx::PartRenderPassT(*renderPasses_) : nullptr); }
}

inline PartBundleT &PartBundleT::operator=(PartBundleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(capacity, o.capacity);
  std::swap(simulationRoutines, o.simulationRoutines);
  std::swap(renderPasses, o.renderPasses);
  std::swap(particle, o.particle);
  return *this;
}

inline PartBundleT *PartBundle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PartBundleT>(new PartBundleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PartBundle::UnPackTo(PartBundleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = capacity(); _o->capacity = _e; }
  { auto _e = simulationRoutines_type(); if (_e) { _o->simulationRoutines.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->simulationRoutines[_i].type = static_cast<Fx::RoutineBundle>(_e->Get(_i)); } } }
  { auto _e = simulationRoutines(); if (_e) { _o->simulationRoutines.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->simulationRoutines[_i].value = Fx::RoutineBundleUnion::UnPack(_e->Get(_i), simulationRoutines_type()->GetEnum<RoutineBundle>(_i), _resolver); } } }
  { auto _e = renderPasses(); if (_e) { _o->renderPasses.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->renderPasses[_i]) { _e->Get(_i)->UnPackTo(_o->renderPasses[_i].get(), _resolver); } else { _o->renderPasses[_i] = std::unique_ptr<Fx::PartRenderPassT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = particle(); if (_e) { if(_o->particle) { _e->UnPackTo(_o->particle.get(), _resolver); } else { _o->particle = std::unique_ptr<Fx::TypeLayoutT>(_e->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<PartBundle> PartBundle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePartBundle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PartBundle> CreatePartBundle(flatbuffers::FlatBufferBuilder &_fbb, const PartBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PartBundleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _capacity = _o->capacity;
  auto _simulationRoutines_type = _o->simulationRoutines.size() ? _fbb.CreateVector<uint8_t>(_o->simulationRoutines.size(), [](size_t i, _VectorArgs *__va) { return static_cast<uint8_t>(__va->__o->simulationRoutines[i].type); }, &_va) : 0;
  auto _simulationRoutines = _o->simulationRoutines.size() ? _fbb.CreateVector<flatbuffers::Offset<void>>(_o->simulationRoutines.size(), [](size_t i, _VectorArgs *__va) { return __va->__o->simulationRoutines[i].Pack(*__va->__fbb, __va->__rehasher); }, &_va) : 0;
  auto _renderPasses = _o->renderPasses.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::PartRenderPass>> (_o->renderPasses.size(), [](size_t i, _VectorArgs *__va) { return CreatePartRenderPass(*__va->__fbb, __va->__o->renderPasses[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _particle = _o->particle ? CreateTypeLayout(_fbb, _o->particle.get(), _rehasher) : 0;
  return Fx::CreatePartBundle(
      _fbb,
      _capacity,
      _simulationRoutines_type,
      _simulationRoutines,
      _renderPasses,
      _particle);
}

inline BundleT::BundleT(const BundleT &o)
      : name(o.name),
        signature((o.signature) ? new Fx::BundleSignatureT(*o.signature) : nullptr),
        content(o.content) {
}

inline BundleT &BundleT::operator=(BundleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(name, o.name);
  std::swap(signature, o.signature);
  std::swap(content, o.content);
  return *this;
}

inline BundleT *Bundle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BundleT>(new BundleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Bundle::UnPackTo(BundleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = signature(); if (_e) { if(_o->signature) { _e->UnPackTo(_o->signature.get(), _resolver); } else { _o->signature = std::unique_ptr<Fx::BundleSignatureT>(_e->UnPack(_resolver)); } } }
  { auto _e = content_type(); _o->content.type = _e; }
  { auto _e = content(); if (_e) _o->content.value = Fx::BundleContentUnion::UnPack(_e, content_type(), _resolver); }
}

inline flatbuffers::Offset<Bundle> Bundle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BundleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBundle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Bundle> CreateBundle(flatbuffers::FlatBufferBuilder &_fbb, const BundleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BundleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _signature = _o->signature ? CreateBundleSignature(_fbb, _o->signature.get(), _rehasher) : 0;
  auto _content_type = _o->content.type;
  auto _content = _o->content.Pack(_fbb);
  return Fx::CreateBundle(
      _fbb,
      _name,
      _signature,
      _content_type,
      _content);
}

inline BundleCollectionT::BundleCollectionT(const BundleCollectionT &o) {
  content.reserve(o.content.size());
  for (const auto &content_ : o.content) { content.emplace_back((content_) ? new Fx::BundleT(*content_) : nullptr); }
}

inline BundleCollectionT &BundleCollectionT::operator=(BundleCollectionT o) FLATBUFFERS_NOEXCEPT {
  std::swap(content, o.content);
  return *this;
}

inline BundleCollectionT *BundleCollection::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BundleCollectionT>(new BundleCollectionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BundleCollection::UnPackTo(BundleCollectionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = content(); if (_e) { _o->content.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->content[_i]) { _e->Get(_i)->UnPackTo(_o->content[_i].get(), _resolver); } else { _o->content[_i] = std::unique_ptr<Fx::BundleT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<BundleCollection> BundleCollection::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BundleCollectionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBundleCollection(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BundleCollection> CreateBundleCollection(flatbuffers::FlatBufferBuilder &_fbb, const BundleCollectionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BundleCollectionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _content = _o->content.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::Bundle>> (_o->content.size(), [](size_t i, _VectorArgs *__va) { return CreateBundle(*__va->__fbb, __va->__o->content[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Fx::CreateBundleCollection(
      _fbb,
      _content);
}

inline bool VerifyRoutineBundle(flatbuffers::Verifier &verifier, const void *obj, RoutineBundle type) {
  switch (type) {
    case RoutineBundle_NONE: {
      return true;
    }
    case RoutineBundle_RoutineBytecodeBundle: {
      auto ptr = reinterpret_cast<const Fx::RoutineBytecodeBundle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RoutineBundle_RoutineGLSLBundle: {
      auto ptr = reinterpret_cast<const Fx::RoutineGLSLBundle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyRoutineBundleVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRoutineBundle(
        verifier,  values->Get(i), types->GetEnum<RoutineBundle>(i))) {
      return false;
    }
  }
  return true;
}

inline void *RoutineBundleUnion::UnPack(const void *obj, RoutineBundle type, const flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case RoutineBundle_RoutineBytecodeBundle: {
      auto ptr = reinterpret_cast<const Fx::RoutineBytecodeBundle *>(obj);
      return ptr->UnPack(resolver);
    }
    case RoutineBundle_RoutineGLSLBundle: {
      auto ptr = reinterpret_cast<const Fx::RoutineGLSLBundle *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> RoutineBundleUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case RoutineBundle_RoutineBytecodeBundle: {
      auto ptr = reinterpret_cast<const Fx::RoutineBytecodeBundleT *>(value);
      return CreateRoutineBytecodeBundle(_fbb, ptr, _rehasher).Union();
    }
    case RoutineBundle_RoutineGLSLBundle: {
      auto ptr = reinterpret_cast<const Fx::RoutineGLSLBundleT *>(value);
      return CreateRoutineGLSLBundle(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline RoutineBundleUnion::RoutineBundleUnion(const RoutineBundleUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case RoutineBundle_RoutineBytecodeBundle: {
      value = new Fx::RoutineBytecodeBundleT(*reinterpret_cast<Fx::RoutineBytecodeBundleT *>(u.value));
      break;
    }
    case RoutineBundle_RoutineGLSLBundle: {
      value = new Fx::RoutineGLSLBundleT(*reinterpret_cast<Fx::RoutineGLSLBundleT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void RoutineBundleUnion::Reset() {
  switch (type) {
    case RoutineBundle_RoutineBytecodeBundle: {
      auto ptr = reinterpret_cast<Fx::RoutineBytecodeBundleT *>(value);
      delete ptr;
      break;
    }
    case RoutineBundle_RoutineGLSLBundle: {
      auto ptr = reinterpret_cast<Fx::RoutineGLSLBundleT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = RoutineBundle_NONE;
}

inline bool VerifyBundleContent(flatbuffers::Verifier &verifier, const void *obj, BundleContent type) {
  switch (type) {
    case BundleContent_NONE: {
      return true;
    }
    case BundleContent_PartBundle: {
      auto ptr = reinterpret_cast<const Fx::PartBundle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyBundleContentVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyBundleContent(
        verifier,  values->Get(i), types->GetEnum<BundleContent>(i))) {
      return false;
    }
  }
  return true;
}

inline void *BundleContentUnion::UnPack(const void *obj, BundleContent type, const flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case BundleContent_PartBundle: {
      auto ptr = reinterpret_cast<const Fx::PartBundle *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> BundleContentUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case BundleContent_PartBundle: {
      auto ptr = reinterpret_cast<const Fx::PartBundleT *>(value);
      return CreatePartBundle(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline BundleContentUnion::BundleContentUnion(const BundleContentUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case BundleContent_PartBundle: {
      value = new Fx::PartBundleT(*reinterpret_cast<Fx::PartBundleT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void BundleContentUnion::Reset() {
  switch (type) {
    case BundleContent_PartBundle: {
      auto ptr = reinterpret_cast<Fx::PartBundleT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = BundleContent_NONE;
}

inline const Fx::Bundle *GetBundle(const void *buf) {
  return flatbuffers::GetRoot<Fx::Bundle>(buf);
}

inline const Fx::Bundle *GetSizePrefixedBundle(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Fx::Bundle>(buf);
}

inline bool VerifyBundleBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Fx::Bundle>(nullptr);
}

inline bool VerifySizePrefixedBundleBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Fx::Bundle>(nullptr);
}

inline void FinishBundleBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Fx::Bundle> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedBundleBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Fx::Bundle> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<Fx::BundleT> UnPackBundle(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Fx::BundleT>(GetBundle(buf)->UnPack(res));
}

inline std::unique_ptr<Fx::BundleT> UnPackSizePrefixedBundle(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Fx::BundleT>(GetSizePrefixedBundle(buf)->UnPack(res));
}

}  // namespace Fx

#endif  // FLATBUFFERS_GENERATED_FXBUNDLE_FX_H_
