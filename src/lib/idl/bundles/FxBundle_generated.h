// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FXBUNDLE_FX_H_
#define FLATBUFFERS_GENERATED_FXBUNDLE_FX_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 6,
             "Non-compatible flatbuffers version included");

namespace Fx {

struct BundleSignature;
struct BundleSignatureBuilder;
struct BundleSignatureT;

struct BundleMeta;
struct BundleMetaBuilder;
struct BundleMetaT;

struct TypeField;
struct TypeFieldBuilder;
struct TypeFieldT;

struct TypeLayout;
struct TypeLayoutBuilder;
struct TypeLayoutT;

struct UAVBundle;
struct UAVBundleBuilder;
struct UAVBundleT;

struct GLSLAttribute;
struct GLSLAttributeBuilder;
struct GLSLAttributeT;

struct RoutineBytecodeBundleResources;
struct RoutineBytecodeBundleResourcesBuilder;
struct RoutineBytecodeBundleResourcesT;

struct RoutineBytecodeBundle;
struct RoutineBytecodeBundleBuilder;
struct RoutineBytecodeBundleT;

struct RoutineGLSLBundle;
struct RoutineGLSLBundleBuilder;
struct RoutineGLSLBundleT;

struct PartRenderPass;
struct PartRenderPassBuilder;
struct PartRenderPassT;

struct PartBundle;
struct PartBundleBuilder;
struct PartBundleT;

struct MatRenderPass;
struct MatRenderPassBuilder;
struct MatRenderPassT;

struct MatBundle;
struct MatBundleBuilder;
struct MatBundleT;

struct UISpinner;
struct UISpinnerBuilder;
struct UISpinnerT;

struct UIFloatSpinner;
struct UIFloatSpinnerBuilder;
struct UIFloatSpinnerT;

struct UIColor;
struct UIColorBuilder;
struct UIColorT;

struct UIFloat3;
struct UIFloat3Builder;
struct UIFloat3T;

struct UIFloat;
struct UIFloatBuilder;
struct UIFloatT;

struct UIInt;
struct UIIntBuilder;
struct UIIntT;

struct UIUint;
struct UIUintBuilder;
struct UIUintT;

struct UIBool;
struct UIBoolBuilder;
struct UIBoolT;

struct UIControl;
struct UIControlBuilder;
struct UIControlT;

struct PresetEntry;
struct PresetEntryBuilder;
struct PresetEntryT;

struct Preset;
struct PresetBuilder;
struct PresetT;

struct Bundle;
struct BundleBuilder;
struct BundleT;

struct BundleCollection;
struct BundleCollectionBuilder;
struct BundleCollectionT;

enum RoutineBundle : uint8_t {
  RoutineBundle_NONE = 0,
  RoutineBundle_RoutineBytecodeBundle = 1,
  RoutineBundle_RoutineGLSLBundle = 2,
  RoutineBundle_MIN = RoutineBundle_NONE,
  RoutineBundle_MAX = RoutineBundle_RoutineGLSLBundle
};

inline const RoutineBundle (&EnumValuesRoutineBundle())[3] {
  static const RoutineBundle values[] = {
    RoutineBundle_NONE,
    RoutineBundle_RoutineBytecodeBundle,
    RoutineBundle_RoutineGLSLBundle
  };
  return values;
}

inline const char * const *EnumNamesRoutineBundle() {
  static const char * const names[4] = {
    "NONE",
    "RoutineBytecodeBundle",
    "RoutineGLSLBundle",
    nullptr
  };
  return names;
}

inline const char *EnumNameRoutineBundle(RoutineBundle e) {
  if (flatbuffers::IsOutRange(e, RoutineBundle_NONE, RoutineBundle_RoutineGLSLBundle)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRoutineBundle()[index];
}

template<typename T> struct RoutineBundleTraits {
  static const RoutineBundle enum_value = RoutineBundle_NONE;
};

template<> struct RoutineBundleTraits<Fx::RoutineBytecodeBundle> {
  static const RoutineBundle enum_value = RoutineBundle_RoutineBytecodeBundle;
};

template<> struct RoutineBundleTraits<Fx::RoutineGLSLBundle> {
  static const RoutineBundle enum_value = RoutineBundle_RoutineGLSLBundle;
};

template<typename T> struct RoutineBundleUnionTraits {
  static const RoutineBundle enum_value = RoutineBundle_NONE;
};

template<> struct RoutineBundleUnionTraits<Fx::RoutineBytecodeBundleT> {
  static const RoutineBundle enum_value = RoutineBundle_RoutineBytecodeBundle;
};

template<> struct RoutineBundleUnionTraits<Fx::RoutineGLSLBundleT> {
  static const RoutineBundle enum_value = RoutineBundle_RoutineGLSLBundle;
};

struct RoutineBundleUnion {
  RoutineBundle type;
  void *value;

  RoutineBundleUnion() : type(RoutineBundle_NONE), value(nullptr) {}
  RoutineBundleUnion(RoutineBundleUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(RoutineBundle_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  RoutineBundleUnion(const RoutineBundleUnion &);
  RoutineBundleUnion &operator=(const RoutineBundleUnion &u)
    { RoutineBundleUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  RoutineBundleUnion &operator=(RoutineBundleUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~RoutineBundleUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = RoutineBundleUnionTraits<RT>::enum_value;
    if (type != RoutineBundle_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, RoutineBundle type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  Fx::RoutineBytecodeBundleT *AsRoutineBytecodeBundle() {
    return type == RoutineBundle_RoutineBytecodeBundle ?
      reinterpret_cast<Fx::RoutineBytecodeBundleT *>(value) : nullptr;
  }
  const Fx::RoutineBytecodeBundleT *AsRoutineBytecodeBundle() const {
    return type == RoutineBundle_RoutineBytecodeBundle ?
      reinterpret_cast<const Fx::RoutineBytecodeBundleT *>(value) : nullptr;
  }
  Fx::RoutineGLSLBundleT *AsRoutineGLSLBundle() {
    return type == RoutineBundle_RoutineGLSLBundle ?
      reinterpret_cast<Fx::RoutineGLSLBundleT *>(value) : nullptr;
  }
  const Fx::RoutineGLSLBundleT *AsRoutineGLSLBundle() const {
    return type == RoutineBundle_RoutineGLSLBundle ?
      reinterpret_cast<const Fx::RoutineGLSLBundleT *>(value) : nullptr;
  }
};

bool VerifyRoutineBundle(flatbuffers::Verifier &verifier, const void *obj, RoutineBundle type);
bool VerifyRoutineBundleVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum EPartSimRoutines : int16_t {
  EPartSimRoutines_k_Reset = 0,
  EPartSimRoutines_k_Spawn = 1,
  EPartSimRoutines_k_Init = 2,
  EPartSimRoutines_k_Update = 3,
  EPartSimRoutines_k_Last = 4,
  EPartSimRoutines_MIN = EPartSimRoutines_k_Reset,
  EPartSimRoutines_MAX = EPartSimRoutines_k_Last
};

inline const EPartSimRoutines (&EnumValuesEPartSimRoutines())[5] {
  static const EPartSimRoutines values[] = {
    EPartSimRoutines_k_Reset,
    EPartSimRoutines_k_Spawn,
    EPartSimRoutines_k_Init,
    EPartSimRoutines_k_Update,
    EPartSimRoutines_k_Last
  };
  return values;
}

inline const char * const *EnumNamesEPartSimRoutines() {
  static const char * const names[6] = {
    "k_Reset",
    "k_Spawn",
    "k_Init",
    "k_Update",
    "k_Last",
    nullptr
  };
  return names;
}

inline const char *EnumNameEPartSimRoutines(EPartSimRoutines e) {
  if (flatbuffers::IsOutRange(e, EPartSimRoutines_k_Reset, EPartSimRoutines_k_Last)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEPartSimRoutines()[index];
}

enum EPartRenderRoutines : int16_t {
  EPartRenderRoutines_k_Prerender = 0,
  EPartRenderRoutines_k_Vertex = 1,
  EPartRenderRoutines_k_Pixel = 2,
  EPartRenderRoutines_k_Last = 3,
  EPartRenderRoutines_MIN = EPartRenderRoutines_k_Prerender,
  EPartRenderRoutines_MAX = EPartRenderRoutines_k_Last
};

inline const EPartRenderRoutines (&EnumValuesEPartRenderRoutines())[4] {
  static const EPartRenderRoutines values[] = {
    EPartRenderRoutines_k_Prerender,
    EPartRenderRoutines_k_Vertex,
    EPartRenderRoutines_k_Pixel,
    EPartRenderRoutines_k_Last
  };
  return values;
}

inline const char * const *EnumNamesEPartRenderRoutines() {
  static const char * const names[5] = {
    "k_Prerender",
    "k_Vertex",
    "k_Pixel",
    "k_Last",
    nullptr
  };
  return names;
}

inline const char *EnumNameEPartRenderRoutines(EPartRenderRoutines e) {
  if (flatbuffers::IsOutRange(e, EPartRenderRoutines_k_Prerender, EPartRenderRoutines_k_Last)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEPartRenderRoutines()[index];
}

enum EMatRenderRoutines : int16_t {
  EMatRenderRoutines_k_Vertex = 0,
  EMatRenderRoutines_k_Pixel = 1,
  EMatRenderRoutines_k_Last = 2,
  EMatRenderRoutines_MIN = EMatRenderRoutines_k_Vertex,
  EMatRenderRoutines_MAX = EMatRenderRoutines_k_Last
};

inline const EMatRenderRoutines (&EnumValuesEMatRenderRoutines())[3] {
  static const EMatRenderRoutines values[] = {
    EMatRenderRoutines_k_Vertex,
    EMatRenderRoutines_k_Pixel,
    EMatRenderRoutines_k_Last
  };
  return values;
}

inline const char * const *EnumNamesEMatRenderRoutines() {
  static const char * const names[4] = {
    "k_Vertex",
    "k_Pixel",
    "k_Last",
    nullptr
  };
  return names;
}

inline const char *EnumNameEMatRenderRoutines(EMatRenderRoutines e) {
  if (flatbuffers::IsOutRange(e, EMatRenderRoutines_k_Vertex, EMatRenderRoutines_k_Last)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEMatRenderRoutines()[index];
}

enum BundleContent : uint8_t {
  BundleContent_NONE = 0,
  BundleContent_PartBundle = 1,
  BundleContent_MatBundle = 2,
  BundleContent_MIN = BundleContent_NONE,
  BundleContent_MAX = BundleContent_MatBundle
};

inline const BundleContent (&EnumValuesBundleContent())[3] {
  static const BundleContent values[] = {
    BundleContent_NONE,
    BundleContent_PartBundle,
    BundleContent_MatBundle
  };
  return values;
}

inline const char * const *EnumNamesBundleContent() {
  static const char * const names[4] = {
    "NONE",
    "PartBundle",
    "MatBundle",
    nullptr
  };
  return names;
}

inline const char *EnumNameBundleContent(BundleContent e) {
  if (flatbuffers::IsOutRange(e, BundleContent_NONE, BundleContent_MatBundle)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBundleContent()[index];
}

template<typename T> struct BundleContentTraits {
  static const BundleContent enum_value = BundleContent_NONE;
};

template<> struct BundleContentTraits<Fx::PartBundle> {
  static const BundleContent enum_value = BundleContent_PartBundle;
};

template<> struct BundleContentTraits<Fx::MatBundle> {
  static const BundleContent enum_value = BundleContent_MatBundle;
};

template<typename T> struct BundleContentUnionTraits {
  static const BundleContent enum_value = BundleContent_NONE;
};

template<> struct BundleContentUnionTraits<Fx::PartBundleT> {
  static const BundleContent enum_value = BundleContent_PartBundle;
};

template<> struct BundleContentUnionTraits<Fx::MatBundleT> {
  static const BundleContent enum_value = BundleContent_MatBundle;
};

struct BundleContentUnion {
  BundleContent type;
  void *value;

  BundleContentUnion() : type(BundleContent_NONE), value(nullptr) {}
  BundleContentUnion(BundleContentUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(BundleContent_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  BundleContentUnion(const BundleContentUnion &);
  BundleContentUnion &operator=(const BundleContentUnion &u)
    { BundleContentUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  BundleContentUnion &operator=(BundleContentUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~BundleContentUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = BundleContentUnionTraits<RT>::enum_value;
    if (type != BundleContent_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, BundleContent type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  Fx::PartBundleT *AsPartBundle() {
    return type == BundleContent_PartBundle ?
      reinterpret_cast<Fx::PartBundleT *>(value) : nullptr;
  }
  const Fx::PartBundleT *AsPartBundle() const {
    return type == BundleContent_PartBundle ?
      reinterpret_cast<const Fx::PartBundleT *>(value) : nullptr;
  }
  Fx::MatBundleT *AsMatBundle() {
    return type == BundleContent_MatBundle ?
      reinterpret_cast<Fx::MatBundleT *>(value) : nullptr;
  }
  const Fx::MatBundleT *AsMatBundle() const {
    return type == BundleContent_MatBundle ?
      reinterpret_cast<const Fx::MatBundleT *>(value) : nullptr;
  }
};

bool VerifyBundleContent(flatbuffers::Verifier &verifier, const void *obj, BundleContent type);
bool VerifyBundleContentVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum UIProperties : uint8_t {
  UIProperties_NONE = 0,
  UIProperties_UISpinner = 1,
  UIProperties_UIFloatSpinner = 2,
  UIProperties_UIColor = 3,
  UIProperties_UIFloat = 4,
  UIProperties_UIFloat3 = 5,
  UIProperties_UIInt = 6,
  UIProperties_UIUint = 7,
  UIProperties_MIN = UIProperties_NONE,
  UIProperties_MAX = UIProperties_UIUint
};

inline const UIProperties (&EnumValuesUIProperties())[8] {
  static const UIProperties values[] = {
    UIProperties_NONE,
    UIProperties_UISpinner,
    UIProperties_UIFloatSpinner,
    UIProperties_UIColor,
    UIProperties_UIFloat,
    UIProperties_UIFloat3,
    UIProperties_UIInt,
    UIProperties_UIUint
  };
  return values;
}

inline const char * const *EnumNamesUIProperties() {
  static const char * const names[9] = {
    "NONE",
    "UISpinner",
    "UIFloatSpinner",
    "UIColor",
    "UIFloat",
    "UIFloat3",
    "UIInt",
    "UIUint",
    nullptr
  };
  return names;
}

inline const char *EnumNameUIProperties(UIProperties e) {
  if (flatbuffers::IsOutRange(e, UIProperties_NONE, UIProperties_UIUint)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUIProperties()[index];
}

template<typename T> struct UIPropertiesTraits {
  static const UIProperties enum_value = UIProperties_NONE;
};

template<> struct UIPropertiesTraits<Fx::UISpinner> {
  static const UIProperties enum_value = UIProperties_UISpinner;
};

template<> struct UIPropertiesTraits<Fx::UIFloatSpinner> {
  static const UIProperties enum_value = UIProperties_UIFloatSpinner;
};

template<> struct UIPropertiesTraits<Fx::UIColor> {
  static const UIProperties enum_value = UIProperties_UIColor;
};

template<> struct UIPropertiesTraits<Fx::UIFloat> {
  static const UIProperties enum_value = UIProperties_UIFloat;
};

template<> struct UIPropertiesTraits<Fx::UIFloat3> {
  static const UIProperties enum_value = UIProperties_UIFloat3;
};

template<> struct UIPropertiesTraits<Fx::UIInt> {
  static const UIProperties enum_value = UIProperties_UIInt;
};

template<> struct UIPropertiesTraits<Fx::UIUint> {
  static const UIProperties enum_value = UIProperties_UIUint;
};

template<typename T> struct UIPropertiesUnionTraits {
  static const UIProperties enum_value = UIProperties_NONE;
};

template<> struct UIPropertiesUnionTraits<Fx::UISpinnerT> {
  static const UIProperties enum_value = UIProperties_UISpinner;
};

template<> struct UIPropertiesUnionTraits<Fx::UIFloatSpinnerT> {
  static const UIProperties enum_value = UIProperties_UIFloatSpinner;
};

template<> struct UIPropertiesUnionTraits<Fx::UIColorT> {
  static const UIProperties enum_value = UIProperties_UIColor;
};

template<> struct UIPropertiesUnionTraits<Fx::UIFloatT> {
  static const UIProperties enum_value = UIProperties_UIFloat;
};

template<> struct UIPropertiesUnionTraits<Fx::UIFloat3T> {
  static const UIProperties enum_value = UIProperties_UIFloat3;
};

template<> struct UIPropertiesUnionTraits<Fx::UIIntT> {
  static const UIProperties enum_value = UIProperties_UIInt;
};

template<> struct UIPropertiesUnionTraits<Fx::UIUintT> {
  static const UIProperties enum_value = UIProperties_UIUint;
};

struct UIPropertiesUnion {
  UIProperties type;
  void *value;

  UIPropertiesUnion() : type(UIProperties_NONE), value(nullptr) {}
  UIPropertiesUnion(UIPropertiesUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(UIProperties_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  UIPropertiesUnion(const UIPropertiesUnion &);
  UIPropertiesUnion &operator=(const UIPropertiesUnion &u)
    { UIPropertiesUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  UIPropertiesUnion &operator=(UIPropertiesUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~UIPropertiesUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = UIPropertiesUnionTraits<RT>::enum_value;
    if (type != UIProperties_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, UIProperties type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  Fx::UISpinnerT *AsUISpinner() {
    return type == UIProperties_UISpinner ?
      reinterpret_cast<Fx::UISpinnerT *>(value) : nullptr;
  }
  const Fx::UISpinnerT *AsUISpinner() const {
    return type == UIProperties_UISpinner ?
      reinterpret_cast<const Fx::UISpinnerT *>(value) : nullptr;
  }
  Fx::UIFloatSpinnerT *AsUIFloatSpinner() {
    return type == UIProperties_UIFloatSpinner ?
      reinterpret_cast<Fx::UIFloatSpinnerT *>(value) : nullptr;
  }
  const Fx::UIFloatSpinnerT *AsUIFloatSpinner() const {
    return type == UIProperties_UIFloatSpinner ?
      reinterpret_cast<const Fx::UIFloatSpinnerT *>(value) : nullptr;
  }
  Fx::UIColorT *AsUIColor() {
    return type == UIProperties_UIColor ?
      reinterpret_cast<Fx::UIColorT *>(value) : nullptr;
  }
  const Fx::UIColorT *AsUIColor() const {
    return type == UIProperties_UIColor ?
      reinterpret_cast<const Fx::UIColorT *>(value) : nullptr;
  }
  Fx::UIFloatT *AsUIFloat() {
    return type == UIProperties_UIFloat ?
      reinterpret_cast<Fx::UIFloatT *>(value) : nullptr;
  }
  const Fx::UIFloatT *AsUIFloat() const {
    return type == UIProperties_UIFloat ?
      reinterpret_cast<const Fx::UIFloatT *>(value) : nullptr;
  }
  Fx::UIFloat3T *AsUIFloat3() {
    return type == UIProperties_UIFloat3 ?
      reinterpret_cast<Fx::UIFloat3T *>(value) : nullptr;
  }
  const Fx::UIFloat3T *AsUIFloat3() const {
    return type == UIProperties_UIFloat3 ?
      reinterpret_cast<const Fx::UIFloat3T *>(value) : nullptr;
  }
  Fx::UIIntT *AsUIInt() {
    return type == UIProperties_UIInt ?
      reinterpret_cast<Fx::UIIntT *>(value) : nullptr;
  }
  const Fx::UIIntT *AsUIInt() const {
    return type == UIProperties_UIInt ?
      reinterpret_cast<const Fx::UIIntT *>(value) : nullptr;
  }
  Fx::UIUintT *AsUIUint() {
    return type == UIProperties_UIUint ?
      reinterpret_cast<Fx::UIUintT *>(value) : nullptr;
  }
  const Fx::UIUintT *AsUIUint() const {
    return type == UIProperties_UIUint ?
      reinterpret_cast<const Fx::UIUintT *>(value) : nullptr;
  }
};

bool VerifyUIProperties(flatbuffers::Verifier &verifier, const void *obj, UIProperties type);
bool VerifyUIPropertiesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct BundleSignatureT : public flatbuffers::NativeTable {
  typedef BundleSignature TableType;
  std::string mode{};
  std::string version{};
  std::string commithash{};
  std::string branch{};
  std::string timestamp{};
};

struct BundleSignature FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BundleSignatureT NativeTableType;
  typedef BundleSignatureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4,
    VT_VERSION = 6,
    VT_COMMITHASH = 8,
    VT_BRANCH = 10,
    VT_TIMESTAMP = 12
  };
  const flatbuffers::String *mode() const {
    return GetPointer<const flatbuffers::String *>(VT_MODE);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::String *commithash() const {
    return GetPointer<const flatbuffers::String *>(VT_COMMITHASH);
  }
  const flatbuffers::String *branch() const {
    return GetPointer<const flatbuffers::String *>(VT_BRANCH);
  }
  const flatbuffers::String *timestamp() const {
    return GetPointer<const flatbuffers::String *>(VT_TIMESTAMP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MODE) &&
           verifier.VerifyString(mode()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyOffset(verifier, VT_COMMITHASH) &&
           verifier.VerifyString(commithash()) &&
           VerifyOffset(verifier, VT_BRANCH) &&
           verifier.VerifyString(branch()) &&
           VerifyOffset(verifier, VT_TIMESTAMP) &&
           verifier.VerifyString(timestamp()) &&
           verifier.EndTable();
  }
  BundleSignatureT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BundleSignatureT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BundleSignature> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BundleSignatureT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BundleSignatureBuilder {
  typedef BundleSignature Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(flatbuffers::Offset<flatbuffers::String> mode) {
    fbb_.AddOffset(BundleSignature::VT_MODE, mode);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(BundleSignature::VT_VERSION, version);
  }
  void add_commithash(flatbuffers::Offset<flatbuffers::String> commithash) {
    fbb_.AddOffset(BundleSignature::VT_COMMITHASH, commithash);
  }
  void add_branch(flatbuffers::Offset<flatbuffers::String> branch) {
    fbb_.AddOffset(BundleSignature::VT_BRANCH, branch);
  }
  void add_timestamp(flatbuffers::Offset<flatbuffers::String> timestamp) {
    fbb_.AddOffset(BundleSignature::VT_TIMESTAMP, timestamp);
  }
  explicit BundleSignatureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BundleSignature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BundleSignature>(end);
    return o;
  }
};

inline flatbuffers::Offset<BundleSignature> CreateBundleSignature(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> mode = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> commithash = 0,
    flatbuffers::Offset<flatbuffers::String> branch = 0,
    flatbuffers::Offset<flatbuffers::String> timestamp = 0) {
  BundleSignatureBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_branch(branch);
  builder_.add_commithash(commithash);
  builder_.add_version(version);
  builder_.add_mode(mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<BundleSignature> CreateBundleSignatureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *mode = nullptr,
    const char *version = nullptr,
    const char *commithash = nullptr,
    const char *branch = nullptr,
    const char *timestamp = nullptr) {
  auto mode__ = mode ? _fbb.CreateString(mode) : 0;
  auto version__ = version ? _fbb.CreateString(version) : 0;
  auto commithash__ = commithash ? _fbb.CreateString(commithash) : 0;
  auto branch__ = branch ? _fbb.CreateString(branch) : 0;
  auto timestamp__ = timestamp ? _fbb.CreateString(timestamp) : 0;
  return Fx::CreateBundleSignature(
      _fbb,
      mode__,
      version__,
      commithash__,
      branch__,
      timestamp__);
}

flatbuffers::Offset<BundleSignature> CreateBundleSignature(flatbuffers::FlatBufferBuilder &_fbb, const BundleSignatureT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BundleMetaT : public flatbuffers::NativeTable {
  typedef BundleMeta TableType;
  std::string author{};
  std::string source{};
};

struct BundleMeta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BundleMetaT NativeTableType;
  typedef BundleMetaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AUTHOR = 4,
    VT_SOURCE = 6
  };
  const flatbuffers::String *author() const {
    return GetPointer<const flatbuffers::String *>(VT_AUTHOR);
  }
  const flatbuffers::String *source() const {
    return GetPointer<const flatbuffers::String *>(VT_SOURCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AUTHOR) &&
           verifier.VerifyString(author()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           verifier.EndTable();
  }
  BundleMetaT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BundleMetaT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BundleMeta> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BundleMetaT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BundleMetaBuilder {
  typedef BundleMeta Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_author(flatbuffers::Offset<flatbuffers::String> author) {
    fbb_.AddOffset(BundleMeta::VT_AUTHOR, author);
  }
  void add_source(flatbuffers::Offset<flatbuffers::String> source) {
    fbb_.AddOffset(BundleMeta::VT_SOURCE, source);
  }
  explicit BundleMetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BundleMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BundleMeta>(end);
    return o;
  }
};

inline flatbuffers::Offset<BundleMeta> CreateBundleMeta(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> author = 0,
    flatbuffers::Offset<flatbuffers::String> source = 0) {
  BundleMetaBuilder builder_(_fbb);
  builder_.add_source(source);
  builder_.add_author(author);
  return builder_.Finish();
}

inline flatbuffers::Offset<BundleMeta> CreateBundleMetaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *author = nullptr,
    const char *source = nullptr) {
  auto author__ = author ? _fbb.CreateString(author) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  return Fx::CreateBundleMeta(
      _fbb,
      author__,
      source__);
}

flatbuffers::Offset<BundleMeta> CreateBundleMeta(flatbuffers::FlatBufferBuilder &_fbb, const BundleMetaT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TypeFieldT : public flatbuffers::NativeTable {
  typedef TypeField TableType;
  std::unique_ptr<Fx::TypeLayoutT> type{};
  std::string name{};
  uint32_t size = 0;
  uint32_t padding = 0;
  TypeFieldT() = default;
  TypeFieldT(const TypeFieldT &o);
  TypeFieldT(TypeFieldT&&) FLATBUFFERS_NOEXCEPT = default;
  TypeFieldT &operator=(TypeFieldT o) FLATBUFFERS_NOEXCEPT;
};

struct TypeField FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TypeFieldT NativeTableType;
  typedef TypeFieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_NAME = 6,
    VT_SIZE = 8,
    VT_PADDING = 10
  };
  const Fx::TypeLayout *type() const {
    return GetPointer<const Fx::TypeLayout *>(VT_TYPE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  uint32_t padding() const {
    return GetField<uint32_t>(VT_PADDING, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_PADDING, 4) &&
           verifier.EndTable();
  }
  TypeFieldT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TypeFieldT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TypeField> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeFieldT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TypeFieldBuilder {
  typedef TypeField Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<Fx::TypeLayout> type) {
    fbb_.AddOffset(TypeField::VT_TYPE, type);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TypeField::VT_NAME, name);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(TypeField::VT_SIZE, size, 0);
  }
  void add_padding(uint32_t padding) {
    fbb_.AddElement<uint32_t>(TypeField::VT_PADDING, padding, 0);
  }
  explicit TypeFieldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TypeField> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TypeField>(end);
    return o;
  }
};

inline flatbuffers::Offset<TypeField> CreateTypeField(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Fx::TypeLayout> type = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t size = 0,
    uint32_t padding = 0) {
  TypeFieldBuilder builder_(_fbb);
  builder_.add_padding(padding);
  builder_.add_size(size);
  builder_.add_name(name);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<TypeField> CreateTypeFieldDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Fx::TypeLayout> type = 0,
    const char *name = nullptr,
    uint32_t size = 0,
    uint32_t padding = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return Fx::CreateTypeField(
      _fbb,
      type,
      name__,
      size,
      padding);
}

flatbuffers::Offset<TypeField> CreateTypeField(flatbuffers::FlatBufferBuilder &_fbb, const TypeFieldT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TypeLayoutT : public flatbuffers::NativeTable {
  typedef TypeLayout TableType;
  std::vector<std::unique_ptr<Fx::TypeFieldT>> fields{};
  int32_t length = 0;
  std::string name{};
  uint32_t size = 0;
  TypeLayoutT() = default;
  TypeLayoutT(const TypeLayoutT &o);
  TypeLayoutT(TypeLayoutT&&) FLATBUFFERS_NOEXCEPT = default;
  TypeLayoutT &operator=(TypeLayoutT o) FLATBUFFERS_NOEXCEPT;
};

struct TypeLayout FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TypeLayoutT NativeTableType;
  typedef TypeLayoutBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIELDS = 4,
    VT_LENGTH = 6,
    VT_NAME = 8,
    VT_SIZE = 10
  };
  const flatbuffers::Vector<flatbuffers::Offset<Fx::TypeField>> *fields() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::TypeField>> *>(VT_FIELDS);
  }
  int32_t length() const {
    return GetField<int32_t>(VT_LENGTH, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FIELDS) &&
           verifier.VerifyVector(fields()) &&
           verifier.VerifyVectorOfTables(fields()) &&
           VerifyField<int32_t>(verifier, VT_LENGTH, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           verifier.EndTable();
  }
  TypeLayoutT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TypeLayoutT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TypeLayout> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeLayoutT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TypeLayoutBuilder {
  typedef TypeLayout Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fields(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::TypeField>>> fields) {
    fbb_.AddOffset(TypeLayout::VT_FIELDS, fields);
  }
  void add_length(int32_t length) {
    fbb_.AddElement<int32_t>(TypeLayout::VT_LENGTH, length, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TypeLayout::VT_NAME, name);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(TypeLayout::VT_SIZE, size, 0);
  }
  explicit TypeLayoutBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TypeLayout> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TypeLayout>(end);
    return o;
  }
};

inline flatbuffers::Offset<TypeLayout> CreateTypeLayout(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::TypeField>>> fields = 0,
    int32_t length = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t size = 0) {
  TypeLayoutBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_name(name);
  builder_.add_length(length);
  builder_.add_fields(fields);
  return builder_.Finish();
}

inline flatbuffers::Offset<TypeLayout> CreateTypeLayoutDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Fx::TypeField>> *fields = nullptr,
    int32_t length = 0,
    const char *name = nullptr,
    uint32_t size = 0) {
  auto fields__ = fields ? _fbb.CreateVector<flatbuffers::Offset<Fx::TypeField>>(*fields) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return Fx::CreateTypeLayout(
      _fbb,
      fields__,
      length,
      name__,
      size);
}

flatbuffers::Offset<TypeLayout> CreateTypeLayout(flatbuffers::FlatBufferBuilder &_fbb, const TypeLayoutT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UAVBundleT : public flatbuffers::NativeTable {
  typedef UAVBundle TableType;
  std::string name{};
  uint32_t slot = 0;
  uint32_t stride = 0;
  std::unique_ptr<Fx::TypeLayoutT> type{};
  UAVBundleT() = default;
  UAVBundleT(const UAVBundleT &o);
  UAVBundleT(UAVBundleT&&) FLATBUFFERS_NOEXCEPT = default;
  UAVBundleT &operator=(UAVBundleT o) FLATBUFFERS_NOEXCEPT;
};

struct UAVBundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UAVBundleT NativeTableType;
  typedef UAVBundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SLOT = 6,
    VT_STRIDE = 8,
    VT_TYPE = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t slot() const {
    return GetField<uint32_t>(VT_SLOT, 0);
  }
  uint32_t stride() const {
    return GetField<uint32_t>(VT_STRIDE, 0);
  }
  const Fx::TypeLayout *type() const {
    return GetPointer<const Fx::TypeLayout *>(VT_TYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_SLOT, 4) &&
           VerifyField<uint32_t>(verifier, VT_STRIDE, 4) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           verifier.EndTable();
  }
  UAVBundleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UAVBundleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UAVBundle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UAVBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UAVBundleBuilder {
  typedef UAVBundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(UAVBundle::VT_NAME, name);
  }
  void add_slot(uint32_t slot) {
    fbb_.AddElement<uint32_t>(UAVBundle::VT_SLOT, slot, 0);
  }
  void add_stride(uint32_t stride) {
    fbb_.AddElement<uint32_t>(UAVBundle::VT_STRIDE, stride, 0);
  }
  void add_type(flatbuffers::Offset<Fx::TypeLayout> type) {
    fbb_.AddOffset(UAVBundle::VT_TYPE, type);
  }
  explicit UAVBundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UAVBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UAVBundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<UAVBundle> CreateUAVBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t slot = 0,
    uint32_t stride = 0,
    flatbuffers::Offset<Fx::TypeLayout> type = 0) {
  UAVBundleBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_stride(stride);
  builder_.add_slot(slot);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<UAVBundle> CreateUAVBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t slot = 0,
    uint32_t stride = 0,
    flatbuffers::Offset<Fx::TypeLayout> type = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return Fx::CreateUAVBundle(
      _fbb,
      name__,
      slot,
      stride,
      type);
}

flatbuffers::Offset<UAVBundle> CreateUAVBundle(flatbuffers::FlatBufferBuilder &_fbb, const UAVBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GLSLAttributeT : public flatbuffers::NativeTable {
  typedef GLSLAttribute TableType;
  uint32_t size = 0;
  uint32_t offset = 0;
  std::string name{};
};

struct GLSLAttribute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GLSLAttributeT NativeTableType;
  typedef GLSLAttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIZE = 4,
    VT_OFFSET = 6,
    VT_NAME = 8
  };
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  uint32_t offset() const {
    return GetField<uint32_t>(VT_OFFSET, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_OFFSET, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
  GLSLAttributeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GLSLAttributeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GLSLAttribute> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GLSLAttributeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GLSLAttributeBuilder {
  typedef GLSLAttribute Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(GLSLAttribute::VT_SIZE, size, 0);
  }
  void add_offset(uint32_t offset) {
    fbb_.AddElement<uint32_t>(GLSLAttribute::VT_OFFSET, offset, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(GLSLAttribute::VT_NAME, name);
  }
  explicit GLSLAttributeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GLSLAttribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GLSLAttribute>(end);
    return o;
  }
};

inline flatbuffers::Offset<GLSLAttribute> CreateGLSLAttribute(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t size = 0,
    uint32_t offset = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  GLSLAttributeBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_offset(offset);
  builder_.add_size(size);
  return builder_.Finish();
}

inline flatbuffers::Offset<GLSLAttribute> CreateGLSLAttributeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t size = 0,
    uint32_t offset = 0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return Fx::CreateGLSLAttribute(
      _fbb,
      size,
      offset,
      name__);
}

flatbuffers::Offset<GLSLAttribute> CreateGLSLAttribute(flatbuffers::FlatBufferBuilder &_fbb, const GLSLAttributeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RoutineBytecodeBundleResourcesT : public flatbuffers::NativeTable {
  typedef RoutineBytecodeBundleResources TableType;
  std::vector<std::unique_ptr<Fx::UAVBundleT>> uavs{};
  RoutineBytecodeBundleResourcesT() = default;
  RoutineBytecodeBundleResourcesT(const RoutineBytecodeBundleResourcesT &o);
  RoutineBytecodeBundleResourcesT(RoutineBytecodeBundleResourcesT&&) FLATBUFFERS_NOEXCEPT = default;
  RoutineBytecodeBundleResourcesT &operator=(RoutineBytecodeBundleResourcesT o) FLATBUFFERS_NOEXCEPT;
};

struct RoutineBytecodeBundleResources FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RoutineBytecodeBundleResourcesT NativeTableType;
  typedef RoutineBytecodeBundleResourcesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UAVS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Fx::UAVBundle>> *uavs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::UAVBundle>> *>(VT_UAVS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UAVS) &&
           verifier.VerifyVector(uavs()) &&
           verifier.VerifyVectorOfTables(uavs()) &&
           verifier.EndTable();
  }
  RoutineBytecodeBundleResourcesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RoutineBytecodeBundleResourcesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RoutineBytecodeBundleResources> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoutineBytecodeBundleResourcesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RoutineBytecodeBundleResourcesBuilder {
  typedef RoutineBytecodeBundleResources Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uavs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::UAVBundle>>> uavs) {
    fbb_.AddOffset(RoutineBytecodeBundleResources::VT_UAVS, uavs);
  }
  explicit RoutineBytecodeBundleResourcesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RoutineBytecodeBundleResources> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RoutineBytecodeBundleResources>(end);
    return o;
  }
};

inline flatbuffers::Offset<RoutineBytecodeBundleResources> CreateRoutineBytecodeBundleResources(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::UAVBundle>>> uavs = 0) {
  RoutineBytecodeBundleResourcesBuilder builder_(_fbb);
  builder_.add_uavs(uavs);
  return builder_.Finish();
}

inline flatbuffers::Offset<RoutineBytecodeBundleResources> CreateRoutineBytecodeBundleResourcesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Fx::UAVBundle>> *uavs = nullptr) {
  auto uavs__ = uavs ? _fbb.CreateVector<flatbuffers::Offset<Fx::UAVBundle>>(*uavs) : 0;
  return Fx::CreateRoutineBytecodeBundleResources(
      _fbb,
      uavs__);
}

flatbuffers::Offset<RoutineBytecodeBundleResources> CreateRoutineBytecodeBundleResources(flatbuffers::FlatBufferBuilder &_fbb, const RoutineBytecodeBundleResourcesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RoutineBytecodeBundleT : public flatbuffers::NativeTable {
  typedef RoutineBytecodeBundle TableType;
  std::vector<uint8_t> code{};
  std::unique_ptr<Fx::RoutineBytecodeBundleResourcesT> resources{};
  std::vector<uint32_t> numthreads{};
  RoutineBytecodeBundleT() = default;
  RoutineBytecodeBundleT(const RoutineBytecodeBundleT &o);
  RoutineBytecodeBundleT(RoutineBytecodeBundleT&&) FLATBUFFERS_NOEXCEPT = default;
  RoutineBytecodeBundleT &operator=(RoutineBytecodeBundleT o) FLATBUFFERS_NOEXCEPT;
};

struct RoutineBytecodeBundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RoutineBytecodeBundleT NativeTableType;
  typedef RoutineBytecodeBundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_RESOURCES = 6,
    VT_NUMTHREADS = 8
  };
  const flatbuffers::Vector<uint8_t> *code() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CODE);
  }
  const Fx::RoutineBytecodeBundleResources *resources() const {
    return GetPointer<const Fx::RoutineBytecodeBundleResources *>(VT_RESOURCES);
  }
  const flatbuffers::Vector<uint32_t> *numthreads() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_NUMTHREADS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CODE) &&
           verifier.VerifyVector(code()) &&
           VerifyOffset(verifier, VT_RESOURCES) &&
           verifier.VerifyTable(resources()) &&
           VerifyOffset(verifier, VT_NUMTHREADS) &&
           verifier.VerifyVector(numthreads()) &&
           verifier.EndTable();
  }
  RoutineBytecodeBundleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RoutineBytecodeBundleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RoutineBytecodeBundle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoutineBytecodeBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RoutineBytecodeBundleBuilder {
  typedef RoutineBytecodeBundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> code) {
    fbb_.AddOffset(RoutineBytecodeBundle::VT_CODE, code);
  }
  void add_resources(flatbuffers::Offset<Fx::RoutineBytecodeBundleResources> resources) {
    fbb_.AddOffset(RoutineBytecodeBundle::VT_RESOURCES, resources);
  }
  void add_numthreads(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> numthreads) {
    fbb_.AddOffset(RoutineBytecodeBundle::VT_NUMTHREADS, numthreads);
  }
  explicit RoutineBytecodeBundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RoutineBytecodeBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RoutineBytecodeBundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<RoutineBytecodeBundle> CreateRoutineBytecodeBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> code = 0,
    flatbuffers::Offset<Fx::RoutineBytecodeBundleResources> resources = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> numthreads = 0) {
  RoutineBytecodeBundleBuilder builder_(_fbb);
  builder_.add_numthreads(numthreads);
  builder_.add_resources(resources);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<RoutineBytecodeBundle> CreateRoutineBytecodeBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *code = nullptr,
    flatbuffers::Offset<Fx::RoutineBytecodeBundleResources> resources = 0,
    const std::vector<uint32_t> *numthreads = nullptr) {
  auto code__ = code ? _fbb.CreateVector<uint8_t>(*code) : 0;
  auto numthreads__ = numthreads ? _fbb.CreateVector<uint32_t>(*numthreads) : 0;
  return Fx::CreateRoutineBytecodeBundle(
      _fbb,
      code__,
      resources,
      numthreads__);
}

flatbuffers::Offset<RoutineBytecodeBundle> CreateRoutineBytecodeBundle(flatbuffers::FlatBufferBuilder &_fbb, const RoutineBytecodeBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RoutineGLSLBundleT : public flatbuffers::NativeTable {
  typedef RoutineGLSLBundle TableType;
  std::string code{};
  std::vector<std::unique_ptr<Fx::GLSLAttributeT>> attributes{};
  RoutineGLSLBundleT() = default;
  RoutineGLSLBundleT(const RoutineGLSLBundleT &o);
  RoutineGLSLBundleT(RoutineGLSLBundleT&&) FLATBUFFERS_NOEXCEPT = default;
  RoutineGLSLBundleT &operator=(RoutineGLSLBundleT o) FLATBUFFERS_NOEXCEPT;
};

struct RoutineGLSLBundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RoutineGLSLBundleT NativeTableType;
  typedef RoutineGLSLBundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_ATTRIBUTES = 6
  };
  const flatbuffers::String *code() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Fx::GLSLAttribute>> *attributes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::GLSLAttribute>> *>(VT_ATTRIBUTES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CODE) &&
           verifier.VerifyString(code()) &&
           VerifyOffset(verifier, VT_ATTRIBUTES) &&
           verifier.VerifyVector(attributes()) &&
           verifier.VerifyVectorOfTables(attributes()) &&
           verifier.EndTable();
  }
  RoutineGLSLBundleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RoutineGLSLBundleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RoutineGLSLBundle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoutineGLSLBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RoutineGLSLBundleBuilder {
  typedef RoutineGLSLBundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(flatbuffers::Offset<flatbuffers::String> code) {
    fbb_.AddOffset(RoutineGLSLBundle::VT_CODE, code);
  }
  void add_attributes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::GLSLAttribute>>> attributes) {
    fbb_.AddOffset(RoutineGLSLBundle::VT_ATTRIBUTES, attributes);
  }
  explicit RoutineGLSLBundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RoutineGLSLBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RoutineGLSLBundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<RoutineGLSLBundle> CreateRoutineGLSLBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> code = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::GLSLAttribute>>> attributes = 0) {
  RoutineGLSLBundleBuilder builder_(_fbb);
  builder_.add_attributes(attributes);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<RoutineGLSLBundle> CreateRoutineGLSLBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *code = nullptr,
    const std::vector<flatbuffers::Offset<Fx::GLSLAttribute>> *attributes = nullptr) {
  auto code__ = code ? _fbb.CreateString(code) : 0;
  auto attributes__ = attributes ? _fbb.CreateVector<flatbuffers::Offset<Fx::GLSLAttribute>>(*attributes) : 0;
  return Fx::CreateRoutineGLSLBundle(
      _fbb,
      code__,
      attributes__);
}

flatbuffers::Offset<RoutineGLSLBundle> CreateRoutineGLSLBundle(flatbuffers::FlatBufferBuilder &_fbb, const RoutineGLSLBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PartRenderPassT : public flatbuffers::NativeTable {
  typedef PartRenderPass TableType;
  std::vector<Fx::RoutineBundleUnion> routines{};
  std::string geometry{};
  bool sorting = false;
  uint32_t instanceCount = 0;
  uint32_t stride = 0;
  std::unique_ptr<Fx::TypeLayoutT> instance{};
  PartRenderPassT() = default;
  PartRenderPassT(const PartRenderPassT &o);
  PartRenderPassT(PartRenderPassT&&) FLATBUFFERS_NOEXCEPT = default;
  PartRenderPassT &operator=(PartRenderPassT o) FLATBUFFERS_NOEXCEPT;
};

struct PartRenderPass FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PartRenderPassT NativeTableType;
  typedef PartRenderPassBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROUTINES_TYPE = 4,
    VT_ROUTINES = 6,
    VT_GEOMETRY = 8,
    VT_SORTING = 10,
    VT_INSTANCECOUNT = 12,
    VT_STRIDE = 14,
    VT_INSTANCE = 16
  };
  const flatbuffers::Vector<uint8_t> *routines_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ROUTINES_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *routines() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_ROUTINES);
  }
  const flatbuffers::String *geometry() const {
    return GetPointer<const flatbuffers::String *>(VT_GEOMETRY);
  }
  bool sorting() const {
    return GetField<uint8_t>(VT_SORTING, 0) != 0;
  }
  uint32_t instanceCount() const {
    return GetField<uint32_t>(VT_INSTANCECOUNT, 0);
  }
  uint32_t stride() const {
    return GetField<uint32_t>(VT_STRIDE, 0);
  }
  const Fx::TypeLayout *instance() const {
    return GetPointer<const Fx::TypeLayout *>(VT_INSTANCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROUTINES_TYPE) &&
           verifier.VerifyVector(routines_type()) &&
           VerifyOffset(verifier, VT_ROUTINES) &&
           verifier.VerifyVector(routines()) &&
           VerifyRoutineBundleVector(verifier, routines(), routines_type()) &&
           VerifyOffset(verifier, VT_GEOMETRY) &&
           verifier.VerifyString(geometry()) &&
           VerifyField<uint8_t>(verifier, VT_SORTING, 1) &&
           VerifyField<uint32_t>(verifier, VT_INSTANCECOUNT, 4) &&
           VerifyField<uint32_t>(verifier, VT_STRIDE, 4) &&
           VerifyOffset(verifier, VT_INSTANCE) &&
           verifier.VerifyTable(instance()) &&
           verifier.EndTable();
  }
  PartRenderPassT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PartRenderPassT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PartRenderPass> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartRenderPassT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PartRenderPassBuilder {
  typedef PartRenderPass Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_routines_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> routines_type) {
    fbb_.AddOffset(PartRenderPass::VT_ROUTINES_TYPE, routines_type);
  }
  void add_routines(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> routines) {
    fbb_.AddOffset(PartRenderPass::VT_ROUTINES, routines);
  }
  void add_geometry(flatbuffers::Offset<flatbuffers::String> geometry) {
    fbb_.AddOffset(PartRenderPass::VT_GEOMETRY, geometry);
  }
  void add_sorting(bool sorting) {
    fbb_.AddElement<uint8_t>(PartRenderPass::VT_SORTING, static_cast<uint8_t>(sorting), 0);
  }
  void add_instanceCount(uint32_t instanceCount) {
    fbb_.AddElement<uint32_t>(PartRenderPass::VT_INSTANCECOUNT, instanceCount, 0);
  }
  void add_stride(uint32_t stride) {
    fbb_.AddElement<uint32_t>(PartRenderPass::VT_STRIDE, stride, 0);
  }
  void add_instance(flatbuffers::Offset<Fx::TypeLayout> instance) {
    fbb_.AddOffset(PartRenderPass::VT_INSTANCE, instance);
  }
  explicit PartRenderPassBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PartRenderPass> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PartRenderPass>(end);
    return o;
  }
};

inline flatbuffers::Offset<PartRenderPass> CreatePartRenderPass(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> routines_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> routines = 0,
    flatbuffers::Offset<flatbuffers::String> geometry = 0,
    bool sorting = false,
    uint32_t instanceCount = 0,
    uint32_t stride = 0,
    flatbuffers::Offset<Fx::TypeLayout> instance = 0) {
  PartRenderPassBuilder builder_(_fbb);
  builder_.add_instance(instance);
  builder_.add_stride(stride);
  builder_.add_instanceCount(instanceCount);
  builder_.add_geometry(geometry);
  builder_.add_routines(routines);
  builder_.add_routines_type(routines_type);
  builder_.add_sorting(sorting);
  return builder_.Finish();
}

inline flatbuffers::Offset<PartRenderPass> CreatePartRenderPassDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *routines_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *routines = nullptr,
    const char *geometry = nullptr,
    bool sorting = false,
    uint32_t instanceCount = 0,
    uint32_t stride = 0,
    flatbuffers::Offset<Fx::TypeLayout> instance = 0) {
  auto routines_type__ = routines_type ? _fbb.CreateVector<uint8_t>(*routines_type) : 0;
  auto routines__ = routines ? _fbb.CreateVector<flatbuffers::Offset<void>>(*routines) : 0;
  auto geometry__ = geometry ? _fbb.CreateString(geometry) : 0;
  return Fx::CreatePartRenderPass(
      _fbb,
      routines_type__,
      routines__,
      geometry__,
      sorting,
      instanceCount,
      stride,
      instance);
}

flatbuffers::Offset<PartRenderPass> CreatePartRenderPass(flatbuffers::FlatBufferBuilder &_fbb, const PartRenderPassT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PartBundleT : public flatbuffers::NativeTable {
  typedef PartBundle TableType;
  uint32_t capacity = 0;
  std::vector<Fx::RoutineBundleUnion> simulationRoutines{};
  std::vector<std::unique_ptr<Fx::PartRenderPassT>> renderPasses{};
  std::unique_ptr<Fx::TypeLayoutT> particle{};
  PartBundleT() = default;
  PartBundleT(const PartBundleT &o);
  PartBundleT(PartBundleT&&) FLATBUFFERS_NOEXCEPT = default;
  PartBundleT &operator=(PartBundleT o) FLATBUFFERS_NOEXCEPT;
};

struct PartBundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PartBundleT NativeTableType;
  typedef PartBundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CAPACITY = 4,
    VT_SIMULATIONROUTINES_TYPE = 6,
    VT_SIMULATIONROUTINES = 8,
    VT_RENDERPASSES = 10,
    VT_PARTICLE = 12
  };
  uint32_t capacity() const {
    return GetField<uint32_t>(VT_CAPACITY, 0);
  }
  const flatbuffers::Vector<uint8_t> *simulationRoutines_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SIMULATIONROUTINES_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *simulationRoutines() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_SIMULATIONROUTINES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Fx::PartRenderPass>> *renderPasses() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::PartRenderPass>> *>(VT_RENDERPASSES);
  }
  const Fx::TypeLayout *particle() const {
    return GetPointer<const Fx::TypeLayout *>(VT_PARTICLE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CAPACITY, 4) &&
           VerifyOffset(verifier, VT_SIMULATIONROUTINES_TYPE) &&
           verifier.VerifyVector(simulationRoutines_type()) &&
           VerifyOffset(verifier, VT_SIMULATIONROUTINES) &&
           verifier.VerifyVector(simulationRoutines()) &&
           VerifyRoutineBundleVector(verifier, simulationRoutines(), simulationRoutines_type()) &&
           VerifyOffset(verifier, VT_RENDERPASSES) &&
           verifier.VerifyVector(renderPasses()) &&
           verifier.VerifyVectorOfTables(renderPasses()) &&
           VerifyOffset(verifier, VT_PARTICLE) &&
           verifier.VerifyTable(particle()) &&
           verifier.EndTable();
  }
  PartBundleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PartBundleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PartBundle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PartBundleBuilder {
  typedef PartBundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_capacity(uint32_t capacity) {
    fbb_.AddElement<uint32_t>(PartBundle::VT_CAPACITY, capacity, 0);
  }
  void add_simulationRoutines_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> simulationRoutines_type) {
    fbb_.AddOffset(PartBundle::VT_SIMULATIONROUTINES_TYPE, simulationRoutines_type);
  }
  void add_simulationRoutines(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> simulationRoutines) {
    fbb_.AddOffset(PartBundle::VT_SIMULATIONROUTINES, simulationRoutines);
  }
  void add_renderPasses(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::PartRenderPass>>> renderPasses) {
    fbb_.AddOffset(PartBundle::VT_RENDERPASSES, renderPasses);
  }
  void add_particle(flatbuffers::Offset<Fx::TypeLayout> particle) {
    fbb_.AddOffset(PartBundle::VT_PARTICLE, particle);
  }
  explicit PartBundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PartBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PartBundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<PartBundle> CreatePartBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t capacity = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> simulationRoutines_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> simulationRoutines = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::PartRenderPass>>> renderPasses = 0,
    flatbuffers::Offset<Fx::TypeLayout> particle = 0) {
  PartBundleBuilder builder_(_fbb);
  builder_.add_particle(particle);
  builder_.add_renderPasses(renderPasses);
  builder_.add_simulationRoutines(simulationRoutines);
  builder_.add_simulationRoutines_type(simulationRoutines_type);
  builder_.add_capacity(capacity);
  return builder_.Finish();
}

inline flatbuffers::Offset<PartBundle> CreatePartBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t capacity = 0,
    const std::vector<uint8_t> *simulationRoutines_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *simulationRoutines = nullptr,
    const std::vector<flatbuffers::Offset<Fx::PartRenderPass>> *renderPasses = nullptr,
    flatbuffers::Offset<Fx::TypeLayout> particle = 0) {
  auto simulationRoutines_type__ = simulationRoutines_type ? _fbb.CreateVector<uint8_t>(*simulationRoutines_type) : 0;
  auto simulationRoutines__ = simulationRoutines ? _fbb.CreateVector<flatbuffers::Offset<void>>(*simulationRoutines) : 0;
  auto renderPasses__ = renderPasses ? _fbb.CreateVector<flatbuffers::Offset<Fx::PartRenderPass>>(*renderPasses) : 0;
  return Fx::CreatePartBundle(
      _fbb,
      capacity,
      simulationRoutines_type__,
      simulationRoutines__,
      renderPasses__,
      particle);
}

flatbuffers::Offset<PartBundle> CreatePartBundle(flatbuffers::FlatBufferBuilder &_fbb, const PartBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MatRenderPassT : public flatbuffers::NativeTable {
  typedef MatRenderPass TableType;
  std::vector<Fx::RoutineBundleUnion> routines{};
};

struct MatRenderPass FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MatRenderPassT NativeTableType;
  typedef MatRenderPassBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROUTINES_TYPE = 4,
    VT_ROUTINES = 6
  };
  const flatbuffers::Vector<uint8_t> *routines_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ROUTINES_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *routines() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_ROUTINES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROUTINES_TYPE) &&
           verifier.VerifyVector(routines_type()) &&
           VerifyOffset(verifier, VT_ROUTINES) &&
           verifier.VerifyVector(routines()) &&
           VerifyRoutineBundleVector(verifier, routines(), routines_type()) &&
           verifier.EndTable();
  }
  MatRenderPassT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MatRenderPassT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MatRenderPass> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatRenderPassT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MatRenderPassBuilder {
  typedef MatRenderPass Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_routines_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> routines_type) {
    fbb_.AddOffset(MatRenderPass::VT_ROUTINES_TYPE, routines_type);
  }
  void add_routines(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> routines) {
    fbb_.AddOffset(MatRenderPass::VT_ROUTINES, routines);
  }
  explicit MatRenderPassBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MatRenderPass> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatRenderPass>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatRenderPass> CreateMatRenderPass(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> routines_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> routines = 0) {
  MatRenderPassBuilder builder_(_fbb);
  builder_.add_routines(routines);
  builder_.add_routines_type(routines_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<MatRenderPass> CreateMatRenderPassDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *routines_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *routines = nullptr) {
  auto routines_type__ = routines_type ? _fbb.CreateVector<uint8_t>(*routines_type) : 0;
  auto routines__ = routines ? _fbb.CreateVector<flatbuffers::Offset<void>>(*routines) : 0;
  return Fx::CreateMatRenderPass(
      _fbb,
      routines_type__,
      routines__);
}

flatbuffers::Offset<MatRenderPass> CreateMatRenderPass(flatbuffers::FlatBufferBuilder &_fbb, const MatRenderPassT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MatBundleT : public flatbuffers::NativeTable {
  typedef MatBundle TableType;
  std::vector<std::unique_ptr<Fx::MatRenderPassT>> renderPasses{};
  MatBundleT() = default;
  MatBundleT(const MatBundleT &o);
  MatBundleT(MatBundleT&&) FLATBUFFERS_NOEXCEPT = default;
  MatBundleT &operator=(MatBundleT o) FLATBUFFERS_NOEXCEPT;
};

struct MatBundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MatBundleT NativeTableType;
  typedef MatBundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RENDERPASSES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Fx::MatRenderPass>> *renderPasses() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::MatRenderPass>> *>(VT_RENDERPASSES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RENDERPASSES) &&
           verifier.VerifyVector(renderPasses()) &&
           verifier.VerifyVectorOfTables(renderPasses()) &&
           verifier.EndTable();
  }
  MatBundleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MatBundleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MatBundle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MatBundleBuilder {
  typedef MatBundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_renderPasses(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::MatRenderPass>>> renderPasses) {
    fbb_.AddOffset(MatBundle::VT_RENDERPASSES, renderPasses);
  }
  explicit MatBundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MatBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatBundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatBundle> CreateMatBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::MatRenderPass>>> renderPasses = 0) {
  MatBundleBuilder builder_(_fbb);
  builder_.add_renderPasses(renderPasses);
  return builder_.Finish();
}

inline flatbuffers::Offset<MatBundle> CreateMatBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Fx::MatRenderPass>> *renderPasses = nullptr) {
  auto renderPasses__ = renderPasses ? _fbb.CreateVector<flatbuffers::Offset<Fx::MatRenderPass>>(*renderPasses) : 0;
  return Fx::CreateMatBundle(
      _fbb,
      renderPasses__);
}

flatbuffers::Offset<MatBundle> CreateMatBundle(flatbuffers::FlatBufferBuilder &_fbb, const MatBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UISpinnerT : public flatbuffers::NativeTable {
  typedef UISpinner TableType;
  std::string name{};
  int32_t min = 0;
  int32_t max = 0;
  int32_t step = 0;
  std::vector<uint8_t> value{};
};

struct UISpinner FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UISpinnerT NativeTableType;
  typedef UISpinnerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_MIN = 6,
    VT_MAX = 8,
    VT_STEP = 10,
    VT_VALUE = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t min() const {
    return GetField<int32_t>(VT_MIN, 0);
  }
  int32_t max() const {
    return GetField<int32_t>(VT_MAX, 0);
  }
  int32_t step() const {
    return GetField<int32_t>(VT_STEP, 0);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_MIN, 4) &&
           VerifyField<int32_t>(verifier, VT_MAX, 4) &&
           VerifyField<int32_t>(verifier, VT_STEP, 4) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
  UISpinnerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UISpinnerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UISpinner> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UISpinnerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UISpinnerBuilder {
  typedef UISpinner Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(UISpinner::VT_NAME, name);
  }
  void add_min(int32_t min) {
    fbb_.AddElement<int32_t>(UISpinner::VT_MIN, min, 0);
  }
  void add_max(int32_t max) {
    fbb_.AddElement<int32_t>(UISpinner::VT_MAX, max, 0);
  }
  void add_step(int32_t step) {
    fbb_.AddElement<int32_t>(UISpinner::VT_STEP, step, 0);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(UISpinner::VT_VALUE, value);
  }
  explicit UISpinnerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UISpinner> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UISpinner>(end);
    return o;
  }
};

inline flatbuffers::Offset<UISpinner> CreateUISpinner(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t min = 0,
    int32_t max = 0,
    int32_t step = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  UISpinnerBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_step(step);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<UISpinner> CreateUISpinnerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t min = 0,
    int32_t max = 0,
    int32_t step = 0,
    const std::vector<uint8_t> *value = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;
  return Fx::CreateUISpinner(
      _fbb,
      name__,
      min,
      max,
      step,
      value__);
}

flatbuffers::Offset<UISpinner> CreateUISpinner(flatbuffers::FlatBufferBuilder &_fbb, const UISpinnerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UIFloatSpinnerT : public flatbuffers::NativeTable {
  typedef UIFloatSpinner TableType;
  std::string name{};
  float min = 0.0f;
  float max = 0.0f;
  float step = 0.0f;
  std::vector<uint8_t> value{};
};

struct UIFloatSpinner FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UIFloatSpinnerT NativeTableType;
  typedef UIFloatSpinnerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_MIN = 6,
    VT_MAX = 8,
    VT_STEP = 10,
    VT_VALUE = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  float min() const {
    return GetField<float>(VT_MIN, 0.0f);
  }
  float max() const {
    return GetField<float>(VT_MAX, 0.0f);
  }
  float step() const {
    return GetField<float>(VT_STEP, 0.0f);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<float>(verifier, VT_MIN, 4) &&
           VerifyField<float>(verifier, VT_MAX, 4) &&
           VerifyField<float>(verifier, VT_STEP, 4) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
  UIFloatSpinnerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UIFloatSpinnerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UIFloatSpinner> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UIFloatSpinnerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UIFloatSpinnerBuilder {
  typedef UIFloatSpinner Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(UIFloatSpinner::VT_NAME, name);
  }
  void add_min(float min) {
    fbb_.AddElement<float>(UIFloatSpinner::VT_MIN, min, 0.0f);
  }
  void add_max(float max) {
    fbb_.AddElement<float>(UIFloatSpinner::VT_MAX, max, 0.0f);
  }
  void add_step(float step) {
    fbb_.AddElement<float>(UIFloatSpinner::VT_STEP, step, 0.0f);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(UIFloatSpinner::VT_VALUE, value);
  }
  explicit UIFloatSpinnerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UIFloatSpinner> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UIFloatSpinner>(end);
    return o;
  }
};

inline flatbuffers::Offset<UIFloatSpinner> CreateUIFloatSpinner(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    float min = 0.0f,
    float max = 0.0f,
    float step = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  UIFloatSpinnerBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_step(step);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<UIFloatSpinner> CreateUIFloatSpinnerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    float min = 0.0f,
    float max = 0.0f,
    float step = 0.0f,
    const std::vector<uint8_t> *value = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;
  return Fx::CreateUIFloatSpinner(
      _fbb,
      name__,
      min,
      max,
      step,
      value__);
}

flatbuffers::Offset<UIFloatSpinner> CreateUIFloatSpinner(flatbuffers::FlatBufferBuilder &_fbb, const UIFloatSpinnerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UIColorT : public flatbuffers::NativeTable {
  typedef UIColor TableType;
  std::string name{};
  std::vector<uint8_t> value{};
};

struct UIColor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UIColorT NativeTableType;
  typedef UIColorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
  UIColorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UIColorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UIColor> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UIColorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UIColorBuilder {
  typedef UIColor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(UIColor::VT_NAME, name);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(UIColor::VT_VALUE, value);
  }
  explicit UIColorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UIColor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UIColor>(end);
    return o;
  }
};

inline flatbuffers::Offset<UIColor> CreateUIColor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  UIColorBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<UIColor> CreateUIColorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<uint8_t> *value = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;
  return Fx::CreateUIColor(
      _fbb,
      name__,
      value__);
}

flatbuffers::Offset<UIColor> CreateUIColor(flatbuffers::FlatBufferBuilder &_fbb, const UIColorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UIFloat3T : public flatbuffers::NativeTable {
  typedef UIFloat3 TableType;
  std::string name{};
  std::vector<uint8_t> value{};
};

struct UIFloat3 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UIFloat3T NativeTableType;
  typedef UIFloat3Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
  UIFloat3T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UIFloat3T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UIFloat3> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UIFloat3T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UIFloat3Builder {
  typedef UIFloat3 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(UIFloat3::VT_NAME, name);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(UIFloat3::VT_VALUE, value);
  }
  explicit UIFloat3Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UIFloat3> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UIFloat3>(end);
    return o;
  }
};

inline flatbuffers::Offset<UIFloat3> CreateUIFloat3(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  UIFloat3Builder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<UIFloat3> CreateUIFloat3Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<uint8_t> *value = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;
  return Fx::CreateUIFloat3(
      _fbb,
      name__,
      value__);
}

flatbuffers::Offset<UIFloat3> CreateUIFloat3(flatbuffers::FlatBufferBuilder &_fbb, const UIFloat3T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UIFloatT : public flatbuffers::NativeTable {
  typedef UIFloat TableType;
  std::string name{};
  std::vector<uint8_t> value{};
};

struct UIFloat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UIFloatT NativeTableType;
  typedef UIFloatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
  UIFloatT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UIFloatT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UIFloat> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UIFloatT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UIFloatBuilder {
  typedef UIFloat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(UIFloat::VT_NAME, name);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(UIFloat::VT_VALUE, value);
  }
  explicit UIFloatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UIFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UIFloat>(end);
    return o;
  }
};

inline flatbuffers::Offset<UIFloat> CreateUIFloat(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  UIFloatBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<UIFloat> CreateUIFloatDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<uint8_t> *value = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;
  return Fx::CreateUIFloat(
      _fbb,
      name__,
      value__);
}

flatbuffers::Offset<UIFloat> CreateUIFloat(flatbuffers::FlatBufferBuilder &_fbb, const UIFloatT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UIIntT : public flatbuffers::NativeTable {
  typedef UIInt TableType;
  std::string name{};
  std::vector<uint8_t> value{};
};

struct UIInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UIIntT NativeTableType;
  typedef UIIntBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
  UIIntT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UIIntT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UIInt> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UIIntT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UIIntBuilder {
  typedef UIInt Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(UIInt::VT_NAME, name);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(UIInt::VT_VALUE, value);
  }
  explicit UIIntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UIInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UIInt>(end);
    return o;
  }
};

inline flatbuffers::Offset<UIInt> CreateUIInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  UIIntBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<UIInt> CreateUIIntDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<uint8_t> *value = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;
  return Fx::CreateUIInt(
      _fbb,
      name__,
      value__);
}

flatbuffers::Offset<UIInt> CreateUIInt(flatbuffers::FlatBufferBuilder &_fbb, const UIIntT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UIUintT : public flatbuffers::NativeTable {
  typedef UIUint TableType;
  std::string name{};
  std::vector<uint8_t> value{};
};

struct UIUint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UIUintT NativeTableType;
  typedef UIUintBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
  UIUintT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UIUintT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UIUint> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UIUintT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UIUintBuilder {
  typedef UIUint Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(UIUint::VT_NAME, name);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(UIUint::VT_VALUE, value);
  }
  explicit UIUintBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UIUint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UIUint>(end);
    return o;
  }
};

inline flatbuffers::Offset<UIUint> CreateUIUint(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  UIUintBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<UIUint> CreateUIUintDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<uint8_t> *value = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;
  return Fx::CreateUIUint(
      _fbb,
      name__,
      value__);
}

flatbuffers::Offset<UIUint> CreateUIUint(flatbuffers::FlatBufferBuilder &_fbb, const UIUintT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UIBoolT : public flatbuffers::NativeTable {
  typedef UIBool TableType;
  std::string name{};
  std::vector<uint8_t> value{};
};

struct UIBool FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UIBoolT NativeTableType;
  typedef UIBoolBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
  UIBoolT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UIBoolT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UIBool> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UIBoolT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UIBoolBuilder {
  typedef UIBool Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(UIBool::VT_NAME, name);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(UIBool::VT_VALUE, value);
  }
  explicit UIBoolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UIBool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UIBool>(end);
    return o;
  }
};

inline flatbuffers::Offset<UIBool> CreateUIBool(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  UIBoolBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<UIBool> CreateUIBoolDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<uint8_t> *value = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;
  return Fx::CreateUIBool(
      _fbb,
      name__,
      value__);
}

flatbuffers::Offset<UIBool> CreateUIBool(flatbuffers::FlatBufferBuilder &_fbb, const UIBoolT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UIControlT : public flatbuffers::NativeTable {
  typedef UIControl TableType;
  std::string name{};
  Fx::UIPropertiesUnion props{};
};

struct UIControl FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UIControlT NativeTableType;
  typedef UIControlBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_PROPS_TYPE = 6,
    VT_PROPS = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  Fx::UIProperties props_type() const {
    return static_cast<Fx::UIProperties>(GetField<uint8_t>(VT_PROPS_TYPE, 0));
  }
  const void *props() const {
    return GetPointer<const void *>(VT_PROPS);
  }
  template<typename T> const T *props_as() const;
  const Fx::UISpinner *props_as_UISpinner() const {
    return props_type() == Fx::UIProperties_UISpinner ? static_cast<const Fx::UISpinner *>(props()) : nullptr;
  }
  const Fx::UIFloatSpinner *props_as_UIFloatSpinner() const {
    return props_type() == Fx::UIProperties_UIFloatSpinner ? static_cast<const Fx::UIFloatSpinner *>(props()) : nullptr;
  }
  const Fx::UIColor *props_as_UIColor() const {
    return props_type() == Fx::UIProperties_UIColor ? static_cast<const Fx::UIColor *>(props()) : nullptr;
  }
  const Fx::UIFloat *props_as_UIFloat() const {
    return props_type() == Fx::UIProperties_UIFloat ? static_cast<const Fx::UIFloat *>(props()) : nullptr;
  }
  const Fx::UIFloat3 *props_as_UIFloat3() const {
    return props_type() == Fx::UIProperties_UIFloat3 ? static_cast<const Fx::UIFloat3 *>(props()) : nullptr;
  }
  const Fx::UIInt *props_as_UIInt() const {
    return props_type() == Fx::UIProperties_UIInt ? static_cast<const Fx::UIInt *>(props()) : nullptr;
  }
  const Fx::UIUint *props_as_UIUint() const {
    return props_type() == Fx::UIProperties_UIUint ? static_cast<const Fx::UIUint *>(props()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_PROPS_TYPE, 1) &&
           VerifyOffset(verifier, VT_PROPS) &&
           VerifyUIProperties(verifier, props(), props_type()) &&
           verifier.EndTable();
  }
  UIControlT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UIControlT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UIControl> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UIControlT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const Fx::UISpinner *UIControl::props_as<Fx::UISpinner>() const {
  return props_as_UISpinner();
}

template<> inline const Fx::UIFloatSpinner *UIControl::props_as<Fx::UIFloatSpinner>() const {
  return props_as_UIFloatSpinner();
}

template<> inline const Fx::UIColor *UIControl::props_as<Fx::UIColor>() const {
  return props_as_UIColor();
}

template<> inline const Fx::UIFloat *UIControl::props_as<Fx::UIFloat>() const {
  return props_as_UIFloat();
}

template<> inline const Fx::UIFloat3 *UIControl::props_as<Fx::UIFloat3>() const {
  return props_as_UIFloat3();
}

template<> inline const Fx::UIInt *UIControl::props_as<Fx::UIInt>() const {
  return props_as_UIInt();
}

template<> inline const Fx::UIUint *UIControl::props_as<Fx::UIUint>() const {
  return props_as_UIUint();
}

struct UIControlBuilder {
  typedef UIControl Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(UIControl::VT_NAME, name);
  }
  void add_props_type(Fx::UIProperties props_type) {
    fbb_.AddElement<uint8_t>(UIControl::VT_PROPS_TYPE, static_cast<uint8_t>(props_type), 0);
  }
  void add_props(flatbuffers::Offset<void> props) {
    fbb_.AddOffset(UIControl::VT_PROPS, props);
  }
  explicit UIControlBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UIControl> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UIControl>(end);
    return o;
  }
};

inline flatbuffers::Offset<UIControl> CreateUIControl(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    Fx::UIProperties props_type = Fx::UIProperties_NONE,
    flatbuffers::Offset<void> props = 0) {
  UIControlBuilder builder_(_fbb);
  builder_.add_props(props);
  builder_.add_name(name);
  builder_.add_props_type(props_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<UIControl> CreateUIControlDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    Fx::UIProperties props_type = Fx::UIProperties_NONE,
    flatbuffers::Offset<void> props = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return Fx::CreateUIControl(
      _fbb,
      name__,
      props_type,
      props);
}

flatbuffers::Offset<UIControl> CreateUIControl(flatbuffers::FlatBufferBuilder &_fbb, const UIControlT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PresetEntryT : public flatbuffers::NativeTable {
  typedef PresetEntry TableType;
  std::string name{};
  std::vector<uint8_t> value{};
};

struct PresetEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PresetEntryT NativeTableType;
  typedef PresetEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
  PresetEntryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PresetEntryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PresetEntry> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PresetEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PresetEntryBuilder {
  typedef PresetEntry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PresetEntry::VT_NAME, name);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(PresetEntry::VT_VALUE, value);
  }
  explicit PresetEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PresetEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PresetEntry>(end);
    return o;
  }
};

inline flatbuffers::Offset<PresetEntry> CreatePresetEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  PresetEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<PresetEntry> CreatePresetEntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<uint8_t> *value = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;
  return Fx::CreatePresetEntry(
      _fbb,
      name__,
      value__);
}

flatbuffers::Offset<PresetEntry> CreatePresetEntry(flatbuffers::FlatBufferBuilder &_fbb, const PresetEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PresetT : public flatbuffers::NativeTable {
  typedef Preset TableType;
  std::string name{};
  std::string desc{};
  std::vector<std::unique_ptr<Fx::PresetEntryT>> data{};
  PresetT() = default;
  PresetT(const PresetT &o);
  PresetT(PresetT&&) FLATBUFFERS_NOEXCEPT = default;
  PresetT &operator=(PresetT o) FLATBUFFERS_NOEXCEPT;
};

struct Preset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PresetT NativeTableType;
  typedef PresetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DESC = 6,
    VT_DATA = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *desc() const {
    return GetPointer<const flatbuffers::String *>(VT_DESC);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Fx::PresetEntry>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::PresetEntry>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DESC) &&
           verifier.VerifyString(desc()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
  PresetT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PresetT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Preset> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PresetT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PresetBuilder {
  typedef Preset Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Preset::VT_NAME, name);
  }
  void add_desc(flatbuffers::Offset<flatbuffers::String> desc) {
    fbb_.AddOffset(Preset::VT_DESC, desc);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::PresetEntry>>> data) {
    fbb_.AddOffset(Preset::VT_DATA, data);
  }
  explicit PresetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Preset> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Preset>(end);
    return o;
  }
};

inline flatbuffers::Offset<Preset> CreatePreset(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> desc = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::PresetEntry>>> data = 0) {
  PresetBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_desc(desc);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Preset> CreatePresetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *desc = nullptr,
    const std::vector<flatbuffers::Offset<Fx::PresetEntry>> *data = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto desc__ = desc ? _fbb.CreateString(desc) : 0;
  auto data__ = data ? _fbb.CreateVector<flatbuffers::Offset<Fx::PresetEntry>>(*data) : 0;
  return Fx::CreatePreset(
      _fbb,
      name__,
      desc__,
      data__);
}

flatbuffers::Offset<Preset> CreatePreset(flatbuffers::FlatBufferBuilder &_fbb, const PresetT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BundleT : public flatbuffers::NativeTable {
  typedef Bundle TableType;
  std::string name{};
  std::unique_ptr<Fx::BundleSignatureT> signature{};
  std::unique_ptr<Fx::BundleMetaT> meta{};
  Fx::BundleContentUnion content{};
  std::vector<std::unique_ptr<Fx::UIControlT>> controls{};
  std::vector<std::unique_ptr<Fx::PresetT>> presets{};
  BundleT() = default;
  BundleT(const BundleT &o);
  BundleT(BundleT&&) FLATBUFFERS_NOEXCEPT = default;
  BundleT &operator=(BundleT o) FLATBUFFERS_NOEXCEPT;
};

struct Bundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BundleT NativeTableType;
  typedef BundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SIGNATURE = 6,
    VT_META = 8,
    VT_CONTENT_TYPE = 10,
    VT_CONTENT = 12,
    VT_CONTROLS = 14,
    VT_PRESETS = 16
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const Fx::BundleSignature *signature() const {
    return GetPointer<const Fx::BundleSignature *>(VT_SIGNATURE);
  }
  const Fx::BundleMeta *meta() const {
    return GetPointer<const Fx::BundleMeta *>(VT_META);
  }
  Fx::BundleContent content_type() const {
    return static_cast<Fx::BundleContent>(GetField<uint8_t>(VT_CONTENT_TYPE, 0));
  }
  const void *content() const {
    return GetPointer<const void *>(VT_CONTENT);
  }
  template<typename T> const T *content_as() const;
  const Fx::PartBundle *content_as_PartBundle() const {
    return content_type() == Fx::BundleContent_PartBundle ? static_cast<const Fx::PartBundle *>(content()) : nullptr;
  }
  const Fx::MatBundle *content_as_MatBundle() const {
    return content_type() == Fx::BundleContent_MatBundle ? static_cast<const Fx::MatBundle *>(content()) : nullptr;
  }
  const flatbuffers::Vector<flatbuffers::Offset<Fx::UIControl>> *controls() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::UIControl>> *>(VT_CONTROLS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Fx::Preset>> *presets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::Preset>> *>(VT_PRESETS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyTable(signature()) &&
           VerifyOffset(verifier, VT_META) &&
           verifier.VerifyTable(meta()) &&
           VerifyField<uint8_t>(verifier, VT_CONTENT_TYPE, 1) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           VerifyBundleContent(verifier, content(), content_type()) &&
           VerifyOffset(verifier, VT_CONTROLS) &&
           verifier.VerifyVector(controls()) &&
           verifier.VerifyVectorOfTables(controls()) &&
           VerifyOffset(verifier, VT_PRESETS) &&
           verifier.VerifyVector(presets()) &&
           verifier.VerifyVectorOfTables(presets()) &&
           verifier.EndTable();
  }
  BundleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BundleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Bundle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BundleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const Fx::PartBundle *Bundle::content_as<Fx::PartBundle>() const {
  return content_as_PartBundle();
}

template<> inline const Fx::MatBundle *Bundle::content_as<Fx::MatBundle>() const {
  return content_as_MatBundle();
}

struct BundleBuilder {
  typedef Bundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Bundle::VT_NAME, name);
  }
  void add_signature(flatbuffers::Offset<Fx::BundleSignature> signature) {
    fbb_.AddOffset(Bundle::VT_SIGNATURE, signature);
  }
  void add_meta(flatbuffers::Offset<Fx::BundleMeta> meta) {
    fbb_.AddOffset(Bundle::VT_META, meta);
  }
  void add_content_type(Fx::BundleContent content_type) {
    fbb_.AddElement<uint8_t>(Bundle::VT_CONTENT_TYPE, static_cast<uint8_t>(content_type), 0);
  }
  void add_content(flatbuffers::Offset<void> content) {
    fbb_.AddOffset(Bundle::VT_CONTENT, content);
  }
  void add_controls(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::UIControl>>> controls) {
    fbb_.AddOffset(Bundle::VT_CONTROLS, controls);
  }
  void add_presets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::Preset>>> presets) {
    fbb_.AddOffset(Bundle::VT_PRESETS, presets);
  }
  explicit BundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Bundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Bundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<Bundle> CreateBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<Fx::BundleSignature> signature = 0,
    flatbuffers::Offset<Fx::BundleMeta> meta = 0,
    Fx::BundleContent content_type = Fx::BundleContent_NONE,
    flatbuffers::Offset<void> content = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::UIControl>>> controls = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::Preset>>> presets = 0) {
  BundleBuilder builder_(_fbb);
  builder_.add_presets(presets);
  builder_.add_controls(controls);
  builder_.add_content(content);
  builder_.add_meta(meta);
  builder_.add_signature(signature);
  builder_.add_name(name);
  builder_.add_content_type(content_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Bundle> CreateBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<Fx::BundleSignature> signature = 0,
    flatbuffers::Offset<Fx::BundleMeta> meta = 0,
    Fx::BundleContent content_type = Fx::BundleContent_NONE,
    flatbuffers::Offset<void> content = 0,
    const std::vector<flatbuffers::Offset<Fx::UIControl>> *controls = nullptr,
    const std::vector<flatbuffers::Offset<Fx::Preset>> *presets = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto controls__ = controls ? _fbb.CreateVector<flatbuffers::Offset<Fx::UIControl>>(*controls) : 0;
  auto presets__ = presets ? _fbb.CreateVector<flatbuffers::Offset<Fx::Preset>>(*presets) : 0;
  return Fx::CreateBundle(
      _fbb,
      name__,
      signature,
      meta,
      content_type,
      content,
      controls__,
      presets__);
}

flatbuffers::Offset<Bundle> CreateBundle(flatbuffers::FlatBufferBuilder &_fbb, const BundleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BundleCollectionT : public flatbuffers::NativeTable {
  typedef BundleCollection TableType;
  std::vector<std::unique_ptr<Fx::BundleT>> content{};
  BundleCollectionT() = default;
  BundleCollectionT(const BundleCollectionT &o);
  BundleCollectionT(BundleCollectionT&&) FLATBUFFERS_NOEXCEPT = default;
  BundleCollectionT &operator=(BundleCollectionT o) FLATBUFFERS_NOEXCEPT;
};

struct BundleCollection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BundleCollectionT NativeTableType;
  typedef BundleCollectionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENT = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Fx::Bundle>> *content() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::Bundle>> *>(VT_CONTENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyVector(content()) &&
           verifier.VerifyVectorOfTables(content()) &&
           verifier.EndTable();
  }
  BundleCollectionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BundleCollectionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BundleCollection> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BundleCollectionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BundleCollectionBuilder {
  typedef BundleCollection Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_content(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::Bundle>>> content) {
    fbb_.AddOffset(BundleCollection::VT_CONTENT, content);
  }
  explicit BundleCollectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BundleCollection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BundleCollection>(end);
    return o;
  }
};

inline flatbuffers::Offset<BundleCollection> CreateBundleCollection(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::Bundle>>> content = 0) {
  BundleCollectionBuilder builder_(_fbb);
  builder_.add_content(content);
  return builder_.Finish();
}

inline flatbuffers::Offset<BundleCollection> CreateBundleCollectionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Fx::Bundle>> *content = nullptr) {
  auto content__ = content ? _fbb.CreateVector<flatbuffers::Offset<Fx::Bundle>>(*content) : 0;
  return Fx::CreateBundleCollection(
      _fbb,
      content__);
}

flatbuffers::Offset<BundleCollection> CreateBundleCollection(flatbuffers::FlatBufferBuilder &_fbb, const BundleCollectionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline BundleSignatureT *BundleSignature::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BundleSignatureT>(new BundleSignatureT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BundleSignature::UnPackTo(BundleSignatureT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = mode(); if (_e) _o->mode = _e->str(); }
  { auto _e = version(); if (_e) _o->version = _e->str(); }
  { auto _e = commithash(); if (_e) _o->commithash = _e->str(); }
  { auto _e = branch(); if (_e) _o->branch = _e->str(); }
  { auto _e = timestamp(); if (_e) _o->timestamp = _e->str(); }
}

inline flatbuffers::Offset<BundleSignature> BundleSignature::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BundleSignatureT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBundleSignature(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BundleSignature> CreateBundleSignature(flatbuffers::FlatBufferBuilder &_fbb, const BundleSignatureT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BundleSignatureT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _mode = _o->mode.empty() ? 0 : _fbb.CreateString(_o->mode);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _commithash = _o->commithash.empty() ? 0 : _fbb.CreateString(_o->commithash);
  auto _branch = _o->branch.empty() ? 0 : _fbb.CreateString(_o->branch);
  auto _timestamp = _o->timestamp.empty() ? 0 : _fbb.CreateString(_o->timestamp);
  return Fx::CreateBundleSignature(
      _fbb,
      _mode,
      _version,
      _commithash,
      _branch,
      _timestamp);
}

inline BundleMetaT *BundleMeta::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BundleMetaT>(new BundleMetaT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BundleMeta::UnPackTo(BundleMetaT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = author(); if (_e) _o->author = _e->str(); }
  { auto _e = source(); if (_e) _o->source = _e->str(); }
}

inline flatbuffers::Offset<BundleMeta> BundleMeta::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BundleMetaT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBundleMeta(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BundleMeta> CreateBundleMeta(flatbuffers::FlatBufferBuilder &_fbb, const BundleMetaT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BundleMetaT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _author = _o->author.empty() ? 0 : _fbb.CreateString(_o->author);
  auto _source = _o->source.empty() ? 0 : _fbb.CreateString(_o->source);
  return Fx::CreateBundleMeta(
      _fbb,
      _author,
      _source);
}

inline TypeFieldT::TypeFieldT(const TypeFieldT &o)
      : type((o.type) ? new Fx::TypeLayoutT(*o.type) : nullptr),
        name(o.name),
        size(o.size),
        padding(o.padding) {
}

inline TypeFieldT &TypeFieldT::operator=(TypeFieldT o) FLATBUFFERS_NOEXCEPT {
  std::swap(type, o.type);
  std::swap(name, o.name);
  std::swap(size, o.size);
  std::swap(padding, o.padding);
  return *this;
}

inline TypeFieldT *TypeField::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TypeFieldT>(new TypeFieldT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TypeField::UnPackTo(TypeFieldT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); if (_e) { if(_o->type) { _e->UnPackTo(_o->type.get(), _resolver); } else { _o->type = std::unique_ptr<Fx::TypeLayoutT>(_e->UnPack(_resolver)); } } }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = size(); _o->size = _e; }
  { auto _e = padding(); _o->padding = _e; }
}

inline flatbuffers::Offset<TypeField> TypeField::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeFieldT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTypeField(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TypeField> CreateTypeField(flatbuffers::FlatBufferBuilder &_fbb, const TypeFieldT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TypeFieldT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type ? CreateTypeLayout(_fbb, _o->type.get(), _rehasher) : 0;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _size = _o->size;
  auto _padding = _o->padding;
  return Fx::CreateTypeField(
      _fbb,
      _type,
      _name,
      _size,
      _padding);
}

inline TypeLayoutT::TypeLayoutT(const TypeLayoutT &o)
      : length(o.length),
        name(o.name),
        size(o.size) {
  fields.reserve(o.fields.size());
  for (const auto &fields_ : o.fields) { fields.emplace_back((fields_) ? new Fx::TypeFieldT(*fields_) : nullptr); }
}

inline TypeLayoutT &TypeLayoutT::operator=(TypeLayoutT o) FLATBUFFERS_NOEXCEPT {
  std::swap(fields, o.fields);
  std::swap(length, o.length);
  std::swap(name, o.name);
  std::swap(size, o.size);
  return *this;
}

inline TypeLayoutT *TypeLayout::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TypeLayoutT>(new TypeLayoutT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TypeLayout::UnPackTo(TypeLayoutT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fields(); if (_e) { _o->fields.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->fields[_i]) { _e->Get(_i)->UnPackTo(_o->fields[_i].get(), _resolver); } else { _o->fields[_i] = std::unique_ptr<Fx::TypeFieldT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = length(); _o->length = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = size(); _o->size = _e; }
}

inline flatbuffers::Offset<TypeLayout> TypeLayout::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeLayoutT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTypeLayout(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TypeLayout> CreateTypeLayout(flatbuffers::FlatBufferBuilder &_fbb, const TypeLayoutT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TypeLayoutT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fields = _o->fields.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::TypeField>> (_o->fields.size(), [](size_t i, _VectorArgs *__va) { return CreateTypeField(*__va->__fbb, __va->__o->fields[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _length = _o->length;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _size = _o->size;
  return Fx::CreateTypeLayout(
      _fbb,
      _fields,
      _length,
      _name,
      _size);
}

inline UAVBundleT::UAVBundleT(const UAVBundleT &o)
      : name(o.name),
        slot(o.slot),
        stride(o.stride),
        type((o.type) ? new Fx::TypeLayoutT(*o.type) : nullptr) {
}

inline UAVBundleT &UAVBundleT::operator=(UAVBundleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(name, o.name);
  std::swap(slot, o.slot);
  std::swap(stride, o.stride);
  std::swap(type, o.type);
  return *this;
}

inline UAVBundleT *UAVBundle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UAVBundleT>(new UAVBundleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UAVBundle::UnPackTo(UAVBundleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = slot(); _o->slot = _e; }
  { auto _e = stride(); _o->stride = _e; }
  { auto _e = type(); if (_e) { if(_o->type) { _e->UnPackTo(_o->type.get(), _resolver); } else { _o->type = std::unique_ptr<Fx::TypeLayoutT>(_e->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<UAVBundle> UAVBundle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UAVBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUAVBundle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UAVBundle> CreateUAVBundle(flatbuffers::FlatBufferBuilder &_fbb, const UAVBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UAVBundleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _slot = _o->slot;
  auto _stride = _o->stride;
  auto _type = _o->type ? CreateTypeLayout(_fbb, _o->type.get(), _rehasher) : 0;
  return Fx::CreateUAVBundle(
      _fbb,
      _name,
      _slot,
      _stride,
      _type);
}

inline GLSLAttributeT *GLSLAttribute::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GLSLAttributeT>(new GLSLAttributeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GLSLAttribute::UnPackTo(GLSLAttributeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = size(); _o->size = _e; }
  { auto _e = offset(); _o->offset = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
}

inline flatbuffers::Offset<GLSLAttribute> GLSLAttribute::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GLSLAttributeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGLSLAttribute(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GLSLAttribute> CreateGLSLAttribute(flatbuffers::FlatBufferBuilder &_fbb, const GLSLAttributeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GLSLAttributeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _size = _o->size;
  auto _offset = _o->offset;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  return Fx::CreateGLSLAttribute(
      _fbb,
      _size,
      _offset,
      _name);
}

inline RoutineBytecodeBundleResourcesT::RoutineBytecodeBundleResourcesT(const RoutineBytecodeBundleResourcesT &o) {
  uavs.reserve(o.uavs.size());
  for (const auto &uavs_ : o.uavs) { uavs.emplace_back((uavs_) ? new Fx::UAVBundleT(*uavs_) : nullptr); }
}

inline RoutineBytecodeBundleResourcesT &RoutineBytecodeBundleResourcesT::operator=(RoutineBytecodeBundleResourcesT o) FLATBUFFERS_NOEXCEPT {
  std::swap(uavs, o.uavs);
  return *this;
}

inline RoutineBytecodeBundleResourcesT *RoutineBytecodeBundleResources::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RoutineBytecodeBundleResourcesT>(new RoutineBytecodeBundleResourcesT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RoutineBytecodeBundleResources::UnPackTo(RoutineBytecodeBundleResourcesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uavs(); if (_e) { _o->uavs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->uavs[_i]) { _e->Get(_i)->UnPackTo(_o->uavs[_i].get(), _resolver); } else { _o->uavs[_i] = std::unique_ptr<Fx::UAVBundleT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<RoutineBytecodeBundleResources> RoutineBytecodeBundleResources::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoutineBytecodeBundleResourcesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRoutineBytecodeBundleResources(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RoutineBytecodeBundleResources> CreateRoutineBytecodeBundleResources(flatbuffers::FlatBufferBuilder &_fbb, const RoutineBytecodeBundleResourcesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RoutineBytecodeBundleResourcesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _uavs = _o->uavs.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::UAVBundle>> (_o->uavs.size(), [](size_t i, _VectorArgs *__va) { return CreateUAVBundle(*__va->__fbb, __va->__o->uavs[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Fx::CreateRoutineBytecodeBundleResources(
      _fbb,
      _uavs);
}

inline RoutineBytecodeBundleT::RoutineBytecodeBundleT(const RoutineBytecodeBundleT &o)
      : code(o.code),
        resources((o.resources) ? new Fx::RoutineBytecodeBundleResourcesT(*o.resources) : nullptr),
        numthreads(o.numthreads) {
}

inline RoutineBytecodeBundleT &RoutineBytecodeBundleT::operator=(RoutineBytecodeBundleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(code, o.code);
  std::swap(resources, o.resources);
  std::swap(numthreads, o.numthreads);
  return *this;
}

inline RoutineBytecodeBundleT *RoutineBytecodeBundle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RoutineBytecodeBundleT>(new RoutineBytecodeBundleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RoutineBytecodeBundle::UnPackTo(RoutineBytecodeBundleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = code(); if (_e) { _o->code.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->code.begin()); } }
  { auto _e = resources(); if (_e) { if(_o->resources) { _e->UnPackTo(_o->resources.get(), _resolver); } else { _o->resources = std::unique_ptr<Fx::RoutineBytecodeBundleResourcesT>(_e->UnPack(_resolver)); } } }
  { auto _e = numthreads(); if (_e) { _o->numthreads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->numthreads[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<RoutineBytecodeBundle> RoutineBytecodeBundle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoutineBytecodeBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRoutineBytecodeBundle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RoutineBytecodeBundle> CreateRoutineBytecodeBundle(flatbuffers::FlatBufferBuilder &_fbb, const RoutineBytecodeBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RoutineBytecodeBundleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _code = _o->code.size() ? _fbb.CreateVector(_o->code) : 0;
  auto _resources = _o->resources ? CreateRoutineBytecodeBundleResources(_fbb, _o->resources.get(), _rehasher) : 0;
  auto _numthreads = _o->numthreads.size() ? _fbb.CreateVector(_o->numthreads) : 0;
  return Fx::CreateRoutineBytecodeBundle(
      _fbb,
      _code,
      _resources,
      _numthreads);
}

inline RoutineGLSLBundleT::RoutineGLSLBundleT(const RoutineGLSLBundleT &o)
      : code(o.code) {
  attributes.reserve(o.attributes.size());
  for (const auto &attributes_ : o.attributes) { attributes.emplace_back((attributes_) ? new Fx::GLSLAttributeT(*attributes_) : nullptr); }
}

inline RoutineGLSLBundleT &RoutineGLSLBundleT::operator=(RoutineGLSLBundleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(code, o.code);
  std::swap(attributes, o.attributes);
  return *this;
}

inline RoutineGLSLBundleT *RoutineGLSLBundle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RoutineGLSLBundleT>(new RoutineGLSLBundleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RoutineGLSLBundle::UnPackTo(RoutineGLSLBundleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = code(); if (_e) _o->code = _e->str(); }
  { auto _e = attributes(); if (_e) { _o->attributes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->attributes[_i]) { _e->Get(_i)->UnPackTo(_o->attributes[_i].get(), _resolver); } else { _o->attributes[_i] = std::unique_ptr<Fx::GLSLAttributeT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<RoutineGLSLBundle> RoutineGLSLBundle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoutineGLSLBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRoutineGLSLBundle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RoutineGLSLBundle> CreateRoutineGLSLBundle(flatbuffers::FlatBufferBuilder &_fbb, const RoutineGLSLBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RoutineGLSLBundleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _code = _o->code.empty() ? 0 : _fbb.CreateString(_o->code);
  auto _attributes = _o->attributes.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::GLSLAttribute>> (_o->attributes.size(), [](size_t i, _VectorArgs *__va) { return CreateGLSLAttribute(*__va->__fbb, __va->__o->attributes[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Fx::CreateRoutineGLSLBundle(
      _fbb,
      _code,
      _attributes);
}

inline PartRenderPassT::PartRenderPassT(const PartRenderPassT &o)
      : routines(o.routines),
        geometry(o.geometry),
        sorting(o.sorting),
        instanceCount(o.instanceCount),
        stride(o.stride),
        instance((o.instance) ? new Fx::TypeLayoutT(*o.instance) : nullptr) {
}

inline PartRenderPassT &PartRenderPassT::operator=(PartRenderPassT o) FLATBUFFERS_NOEXCEPT {
  std::swap(routines, o.routines);
  std::swap(geometry, o.geometry);
  std::swap(sorting, o.sorting);
  std::swap(instanceCount, o.instanceCount);
  std::swap(stride, o.stride);
  std::swap(instance, o.instance);
  return *this;
}

inline PartRenderPassT *PartRenderPass::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PartRenderPassT>(new PartRenderPassT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PartRenderPass::UnPackTo(PartRenderPassT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = routines_type(); if (_e) { _o->routines.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->routines[_i].type = static_cast<Fx::RoutineBundle>(_e->Get(_i)); } } }
  { auto _e = routines(); if (_e) { _o->routines.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->routines[_i].value = Fx::RoutineBundleUnion::UnPack(_e->Get(_i), routines_type()->GetEnum<RoutineBundle>(_i), _resolver); } } }
  { auto _e = geometry(); if (_e) _o->geometry = _e->str(); }
  { auto _e = sorting(); _o->sorting = _e; }
  { auto _e = instanceCount(); _o->instanceCount = _e; }
  { auto _e = stride(); _o->stride = _e; }
  { auto _e = instance(); if (_e) { if(_o->instance) { _e->UnPackTo(_o->instance.get(), _resolver); } else { _o->instance = std::unique_ptr<Fx::TypeLayoutT>(_e->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<PartRenderPass> PartRenderPass::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartRenderPassT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePartRenderPass(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PartRenderPass> CreatePartRenderPass(flatbuffers::FlatBufferBuilder &_fbb, const PartRenderPassT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PartRenderPassT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _routines_type = _o->routines.size() ? _fbb.CreateVector<uint8_t>(_o->routines.size(), [](size_t i, _VectorArgs *__va) { return static_cast<uint8_t>(__va->__o->routines[i].type); }, &_va) : 0;
  auto _routines = _o->routines.size() ? _fbb.CreateVector<flatbuffers::Offset<void>>(_o->routines.size(), [](size_t i, _VectorArgs *__va) { return __va->__o->routines[i].Pack(*__va->__fbb, __va->__rehasher); }, &_va) : 0;
  auto _geometry = _o->geometry.empty() ? 0 : _fbb.CreateString(_o->geometry);
  auto _sorting = _o->sorting;
  auto _instanceCount = _o->instanceCount;
  auto _stride = _o->stride;
  auto _instance = _o->instance ? CreateTypeLayout(_fbb, _o->instance.get(), _rehasher) : 0;
  return Fx::CreatePartRenderPass(
      _fbb,
      _routines_type,
      _routines,
      _geometry,
      _sorting,
      _instanceCount,
      _stride,
      _instance);
}

inline PartBundleT::PartBundleT(const PartBundleT &o)
      : capacity(o.capacity),
        simulationRoutines(o.simulationRoutines),
        particle((o.particle) ? new Fx::TypeLayoutT(*o.particle) : nullptr) {
  renderPasses.reserve(o.renderPasses.size());
  for (const auto &renderPasses_ : o.renderPasses) { renderPasses.emplace_back((renderPasses_) ? new Fx::PartRenderPassT(*renderPasses_) : nullptr); }
}

inline PartBundleT &PartBundleT::operator=(PartBundleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(capacity, o.capacity);
  std::swap(simulationRoutines, o.simulationRoutines);
  std::swap(renderPasses, o.renderPasses);
  std::swap(particle, o.particle);
  return *this;
}

inline PartBundleT *PartBundle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PartBundleT>(new PartBundleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PartBundle::UnPackTo(PartBundleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = capacity(); _o->capacity = _e; }
  { auto _e = simulationRoutines_type(); if (_e) { _o->simulationRoutines.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->simulationRoutines[_i].type = static_cast<Fx::RoutineBundle>(_e->Get(_i)); } } }
  { auto _e = simulationRoutines(); if (_e) { _o->simulationRoutines.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->simulationRoutines[_i].value = Fx::RoutineBundleUnion::UnPack(_e->Get(_i), simulationRoutines_type()->GetEnum<RoutineBundle>(_i), _resolver); } } }
  { auto _e = renderPasses(); if (_e) { _o->renderPasses.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->renderPasses[_i]) { _e->Get(_i)->UnPackTo(_o->renderPasses[_i].get(), _resolver); } else { _o->renderPasses[_i] = std::unique_ptr<Fx::PartRenderPassT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = particle(); if (_e) { if(_o->particle) { _e->UnPackTo(_o->particle.get(), _resolver); } else { _o->particle = std::unique_ptr<Fx::TypeLayoutT>(_e->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<PartBundle> PartBundle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePartBundle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PartBundle> CreatePartBundle(flatbuffers::FlatBufferBuilder &_fbb, const PartBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PartBundleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _capacity = _o->capacity;
  auto _simulationRoutines_type = _o->simulationRoutines.size() ? _fbb.CreateVector<uint8_t>(_o->simulationRoutines.size(), [](size_t i, _VectorArgs *__va) { return static_cast<uint8_t>(__va->__o->simulationRoutines[i].type); }, &_va) : 0;
  auto _simulationRoutines = _o->simulationRoutines.size() ? _fbb.CreateVector<flatbuffers::Offset<void>>(_o->simulationRoutines.size(), [](size_t i, _VectorArgs *__va) { return __va->__o->simulationRoutines[i].Pack(*__va->__fbb, __va->__rehasher); }, &_va) : 0;
  auto _renderPasses = _o->renderPasses.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::PartRenderPass>> (_o->renderPasses.size(), [](size_t i, _VectorArgs *__va) { return CreatePartRenderPass(*__va->__fbb, __va->__o->renderPasses[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _particle = _o->particle ? CreateTypeLayout(_fbb, _o->particle.get(), _rehasher) : 0;
  return Fx::CreatePartBundle(
      _fbb,
      _capacity,
      _simulationRoutines_type,
      _simulationRoutines,
      _renderPasses,
      _particle);
}

inline MatRenderPassT *MatRenderPass::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MatRenderPassT>(new MatRenderPassT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MatRenderPass::UnPackTo(MatRenderPassT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = routines_type(); if (_e) { _o->routines.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->routines[_i].type = static_cast<Fx::RoutineBundle>(_e->Get(_i)); } } }
  { auto _e = routines(); if (_e) { _o->routines.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->routines[_i].value = Fx::RoutineBundleUnion::UnPack(_e->Get(_i), routines_type()->GetEnum<RoutineBundle>(_i), _resolver); } } }
}

inline flatbuffers::Offset<MatRenderPass> MatRenderPass::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatRenderPassT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMatRenderPass(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MatRenderPass> CreateMatRenderPass(flatbuffers::FlatBufferBuilder &_fbb, const MatRenderPassT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MatRenderPassT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _routines_type = _o->routines.size() ? _fbb.CreateVector<uint8_t>(_o->routines.size(), [](size_t i, _VectorArgs *__va) { return static_cast<uint8_t>(__va->__o->routines[i].type); }, &_va) : 0;
  auto _routines = _o->routines.size() ? _fbb.CreateVector<flatbuffers::Offset<void>>(_o->routines.size(), [](size_t i, _VectorArgs *__va) { return __va->__o->routines[i].Pack(*__va->__fbb, __va->__rehasher); }, &_va) : 0;
  return Fx::CreateMatRenderPass(
      _fbb,
      _routines_type,
      _routines);
}

inline MatBundleT::MatBundleT(const MatBundleT &o) {
  renderPasses.reserve(o.renderPasses.size());
  for (const auto &renderPasses_ : o.renderPasses) { renderPasses.emplace_back((renderPasses_) ? new Fx::MatRenderPassT(*renderPasses_) : nullptr); }
}

inline MatBundleT &MatBundleT::operator=(MatBundleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(renderPasses, o.renderPasses);
  return *this;
}

inline MatBundleT *MatBundle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MatBundleT>(new MatBundleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MatBundle::UnPackTo(MatBundleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = renderPasses(); if (_e) { _o->renderPasses.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->renderPasses[_i]) { _e->Get(_i)->UnPackTo(_o->renderPasses[_i].get(), _resolver); } else { _o->renderPasses[_i] = std::unique_ptr<Fx::MatRenderPassT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<MatBundle> MatBundle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMatBundle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MatBundle> CreateMatBundle(flatbuffers::FlatBufferBuilder &_fbb, const MatBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MatBundleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _renderPasses = _o->renderPasses.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::MatRenderPass>> (_o->renderPasses.size(), [](size_t i, _VectorArgs *__va) { return CreateMatRenderPass(*__va->__fbb, __va->__o->renderPasses[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Fx::CreateMatBundle(
      _fbb,
      _renderPasses);
}

inline UISpinnerT *UISpinner::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UISpinnerT>(new UISpinnerT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UISpinner::UnPackTo(UISpinnerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = min(); _o->min = _e; }
  { auto _e = max(); _o->max = _e; }
  { auto _e = step(); _o->step = _e; }
  { auto _e = value(); if (_e) { _o->value.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->value.begin()); } }
}

inline flatbuffers::Offset<UISpinner> UISpinner::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UISpinnerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUISpinner(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UISpinner> CreateUISpinner(flatbuffers::FlatBufferBuilder &_fbb, const UISpinnerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UISpinnerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _min = _o->min;
  auto _max = _o->max;
  auto _step = _o->step;
  auto _value = _o->value.size() ? _fbb.CreateVector(_o->value) : 0;
  return Fx::CreateUISpinner(
      _fbb,
      _name,
      _min,
      _max,
      _step,
      _value);
}

inline UIFloatSpinnerT *UIFloatSpinner::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UIFloatSpinnerT>(new UIFloatSpinnerT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UIFloatSpinner::UnPackTo(UIFloatSpinnerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = min(); _o->min = _e; }
  { auto _e = max(); _o->max = _e; }
  { auto _e = step(); _o->step = _e; }
  { auto _e = value(); if (_e) { _o->value.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->value.begin()); } }
}

inline flatbuffers::Offset<UIFloatSpinner> UIFloatSpinner::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UIFloatSpinnerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUIFloatSpinner(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UIFloatSpinner> CreateUIFloatSpinner(flatbuffers::FlatBufferBuilder &_fbb, const UIFloatSpinnerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UIFloatSpinnerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _min = _o->min;
  auto _max = _o->max;
  auto _step = _o->step;
  auto _value = _o->value.size() ? _fbb.CreateVector(_o->value) : 0;
  return Fx::CreateUIFloatSpinner(
      _fbb,
      _name,
      _min,
      _max,
      _step,
      _value);
}

inline UIColorT *UIColor::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UIColorT>(new UIColorT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UIColor::UnPackTo(UIColorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = value(); if (_e) { _o->value.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->value.begin()); } }
}

inline flatbuffers::Offset<UIColor> UIColor::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UIColorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUIColor(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UIColor> CreateUIColor(flatbuffers::FlatBufferBuilder &_fbb, const UIColorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UIColorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _value = _o->value.size() ? _fbb.CreateVector(_o->value) : 0;
  return Fx::CreateUIColor(
      _fbb,
      _name,
      _value);
}

inline UIFloat3T *UIFloat3::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UIFloat3T>(new UIFloat3T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UIFloat3::UnPackTo(UIFloat3T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = value(); if (_e) { _o->value.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->value.begin()); } }
}

inline flatbuffers::Offset<UIFloat3> UIFloat3::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UIFloat3T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUIFloat3(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UIFloat3> CreateUIFloat3(flatbuffers::FlatBufferBuilder &_fbb, const UIFloat3T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UIFloat3T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _value = _o->value.size() ? _fbb.CreateVector(_o->value) : 0;
  return Fx::CreateUIFloat3(
      _fbb,
      _name,
      _value);
}

inline UIFloatT *UIFloat::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UIFloatT>(new UIFloatT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UIFloat::UnPackTo(UIFloatT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = value(); if (_e) { _o->value.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->value.begin()); } }
}

inline flatbuffers::Offset<UIFloat> UIFloat::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UIFloatT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUIFloat(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UIFloat> CreateUIFloat(flatbuffers::FlatBufferBuilder &_fbb, const UIFloatT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UIFloatT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _value = _o->value.size() ? _fbb.CreateVector(_o->value) : 0;
  return Fx::CreateUIFloat(
      _fbb,
      _name,
      _value);
}

inline UIIntT *UIInt::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UIIntT>(new UIIntT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UIInt::UnPackTo(UIIntT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = value(); if (_e) { _o->value.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->value.begin()); } }
}

inline flatbuffers::Offset<UIInt> UIInt::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UIIntT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUIInt(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UIInt> CreateUIInt(flatbuffers::FlatBufferBuilder &_fbb, const UIIntT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UIIntT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _value = _o->value.size() ? _fbb.CreateVector(_o->value) : 0;
  return Fx::CreateUIInt(
      _fbb,
      _name,
      _value);
}

inline UIUintT *UIUint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UIUintT>(new UIUintT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UIUint::UnPackTo(UIUintT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = value(); if (_e) { _o->value.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->value.begin()); } }
}

inline flatbuffers::Offset<UIUint> UIUint::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UIUintT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUIUint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UIUint> CreateUIUint(flatbuffers::FlatBufferBuilder &_fbb, const UIUintT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UIUintT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _value = _o->value.size() ? _fbb.CreateVector(_o->value) : 0;
  return Fx::CreateUIUint(
      _fbb,
      _name,
      _value);
}

inline UIBoolT *UIBool::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UIBoolT>(new UIBoolT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UIBool::UnPackTo(UIBoolT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = value(); if (_e) { _o->value.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->value.begin()); } }
}

inline flatbuffers::Offset<UIBool> UIBool::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UIBoolT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUIBool(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UIBool> CreateUIBool(flatbuffers::FlatBufferBuilder &_fbb, const UIBoolT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UIBoolT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _value = _o->value.size() ? _fbb.CreateVector(_o->value) : 0;
  return Fx::CreateUIBool(
      _fbb,
      _name,
      _value);
}

inline UIControlT *UIControl::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UIControlT>(new UIControlT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UIControl::UnPackTo(UIControlT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = props_type(); _o->props.type = _e; }
  { auto _e = props(); if (_e) _o->props.value = Fx::UIPropertiesUnion::UnPack(_e, props_type(), _resolver); }
}

inline flatbuffers::Offset<UIControl> UIControl::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UIControlT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUIControl(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UIControl> CreateUIControl(flatbuffers::FlatBufferBuilder &_fbb, const UIControlT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UIControlT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _props_type = _o->props.type;
  auto _props = _o->props.Pack(_fbb);
  return Fx::CreateUIControl(
      _fbb,
      _name,
      _props_type,
      _props);
}

inline PresetEntryT *PresetEntry::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PresetEntryT>(new PresetEntryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PresetEntry::UnPackTo(PresetEntryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = value(); if (_e) { _o->value.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->value.begin()); } }
}

inline flatbuffers::Offset<PresetEntry> PresetEntry::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PresetEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePresetEntry(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PresetEntry> CreatePresetEntry(flatbuffers::FlatBufferBuilder &_fbb, const PresetEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PresetEntryT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _value = _o->value.size() ? _fbb.CreateVector(_o->value) : 0;
  return Fx::CreatePresetEntry(
      _fbb,
      _name,
      _value);
}

inline PresetT::PresetT(const PresetT &o)
      : name(o.name),
        desc(o.desc) {
  data.reserve(o.data.size());
  for (const auto &data_ : o.data) { data.emplace_back((data_) ? new Fx::PresetEntryT(*data_) : nullptr); }
}

inline PresetT &PresetT::operator=(PresetT o) FLATBUFFERS_NOEXCEPT {
  std::swap(name, o.name);
  std::swap(desc, o.desc);
  std::swap(data, o.data);
  return *this;
}

inline PresetT *Preset::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PresetT>(new PresetT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Preset::UnPackTo(PresetT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = desc(); if (_e) _o->desc = _e->str(); }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->data[_i]) { _e->Get(_i)->UnPackTo(_o->data[_i].get(), _resolver); } else { _o->data[_i] = std::unique_ptr<Fx::PresetEntryT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<Preset> Preset::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PresetT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePreset(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Preset> CreatePreset(flatbuffers::FlatBufferBuilder &_fbb, const PresetT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PresetT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _desc = _o->desc.empty() ? 0 : _fbb.CreateString(_o->desc);
  auto _data = _o->data.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::PresetEntry>> (_o->data.size(), [](size_t i, _VectorArgs *__va) { return CreatePresetEntry(*__va->__fbb, __va->__o->data[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Fx::CreatePreset(
      _fbb,
      _name,
      _desc,
      _data);
}

inline BundleT::BundleT(const BundleT &o)
      : name(o.name),
        signature((o.signature) ? new Fx::BundleSignatureT(*o.signature) : nullptr),
        meta((o.meta) ? new Fx::BundleMetaT(*o.meta) : nullptr),
        content(o.content) {
  controls.reserve(o.controls.size());
  for (const auto &controls_ : o.controls) { controls.emplace_back((controls_) ? new Fx::UIControlT(*controls_) : nullptr); }
  presets.reserve(o.presets.size());
  for (const auto &presets_ : o.presets) { presets.emplace_back((presets_) ? new Fx::PresetT(*presets_) : nullptr); }
}

inline BundleT &BundleT::operator=(BundleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(name, o.name);
  std::swap(signature, o.signature);
  std::swap(meta, o.meta);
  std::swap(content, o.content);
  std::swap(controls, o.controls);
  std::swap(presets, o.presets);
  return *this;
}

inline BundleT *Bundle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BundleT>(new BundleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Bundle::UnPackTo(BundleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = signature(); if (_e) { if(_o->signature) { _e->UnPackTo(_o->signature.get(), _resolver); } else { _o->signature = std::unique_ptr<Fx::BundleSignatureT>(_e->UnPack(_resolver)); } } }
  { auto _e = meta(); if (_e) { if(_o->meta) { _e->UnPackTo(_o->meta.get(), _resolver); } else { _o->meta = std::unique_ptr<Fx::BundleMetaT>(_e->UnPack(_resolver)); } } }
  { auto _e = content_type(); _o->content.type = _e; }
  { auto _e = content(); if (_e) _o->content.value = Fx::BundleContentUnion::UnPack(_e, content_type(), _resolver); }
  { auto _e = controls(); if (_e) { _o->controls.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->controls[_i]) { _e->Get(_i)->UnPackTo(_o->controls[_i].get(), _resolver); } else { _o->controls[_i] = std::unique_ptr<Fx::UIControlT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = presets(); if (_e) { _o->presets.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->presets[_i]) { _e->Get(_i)->UnPackTo(_o->presets[_i].get(), _resolver); } else { _o->presets[_i] = std::unique_ptr<Fx::PresetT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<Bundle> Bundle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BundleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBundle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Bundle> CreateBundle(flatbuffers::FlatBufferBuilder &_fbb, const BundleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BundleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _signature = _o->signature ? CreateBundleSignature(_fbb, _o->signature.get(), _rehasher) : 0;
  auto _meta = _o->meta ? CreateBundleMeta(_fbb, _o->meta.get(), _rehasher) : 0;
  auto _content_type = _o->content.type;
  auto _content = _o->content.Pack(_fbb);
  auto _controls = _o->controls.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::UIControl>> (_o->controls.size(), [](size_t i, _VectorArgs *__va) { return CreateUIControl(*__va->__fbb, __va->__o->controls[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _presets = _o->presets.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::Preset>> (_o->presets.size(), [](size_t i, _VectorArgs *__va) { return CreatePreset(*__va->__fbb, __va->__o->presets[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Fx::CreateBundle(
      _fbb,
      _name,
      _signature,
      _meta,
      _content_type,
      _content,
      _controls,
      _presets);
}

inline BundleCollectionT::BundleCollectionT(const BundleCollectionT &o) {
  content.reserve(o.content.size());
  for (const auto &content_ : o.content) { content.emplace_back((content_) ? new Fx::BundleT(*content_) : nullptr); }
}

inline BundleCollectionT &BundleCollectionT::operator=(BundleCollectionT o) FLATBUFFERS_NOEXCEPT {
  std::swap(content, o.content);
  return *this;
}

inline BundleCollectionT *BundleCollection::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BundleCollectionT>(new BundleCollectionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BundleCollection::UnPackTo(BundleCollectionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = content(); if (_e) { _o->content.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->content[_i]) { _e->Get(_i)->UnPackTo(_o->content[_i].get(), _resolver); } else { _o->content[_i] = std::unique_ptr<Fx::BundleT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<BundleCollection> BundleCollection::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BundleCollectionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBundleCollection(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BundleCollection> CreateBundleCollection(flatbuffers::FlatBufferBuilder &_fbb, const BundleCollectionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BundleCollectionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _content = _o->content.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::Bundle>> (_o->content.size(), [](size_t i, _VectorArgs *__va) { return CreateBundle(*__va->__fbb, __va->__o->content[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Fx::CreateBundleCollection(
      _fbb,
      _content);
}

inline bool VerifyRoutineBundle(flatbuffers::Verifier &verifier, const void *obj, RoutineBundle type) {
  switch (type) {
    case RoutineBundle_NONE: {
      return true;
    }
    case RoutineBundle_RoutineBytecodeBundle: {
      auto ptr = reinterpret_cast<const Fx::RoutineBytecodeBundle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RoutineBundle_RoutineGLSLBundle: {
      auto ptr = reinterpret_cast<const Fx::RoutineGLSLBundle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyRoutineBundleVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRoutineBundle(
        verifier,  values->Get(i), types->GetEnum<RoutineBundle>(i))) {
      return false;
    }
  }
  return true;
}

inline void *RoutineBundleUnion::UnPack(const void *obj, RoutineBundle type, const flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case RoutineBundle_RoutineBytecodeBundle: {
      auto ptr = reinterpret_cast<const Fx::RoutineBytecodeBundle *>(obj);
      return ptr->UnPack(resolver);
    }
    case RoutineBundle_RoutineGLSLBundle: {
      auto ptr = reinterpret_cast<const Fx::RoutineGLSLBundle *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> RoutineBundleUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case RoutineBundle_RoutineBytecodeBundle: {
      auto ptr = reinterpret_cast<const Fx::RoutineBytecodeBundleT *>(value);
      return CreateRoutineBytecodeBundle(_fbb, ptr, _rehasher).Union();
    }
    case RoutineBundle_RoutineGLSLBundle: {
      auto ptr = reinterpret_cast<const Fx::RoutineGLSLBundleT *>(value);
      return CreateRoutineGLSLBundle(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline RoutineBundleUnion::RoutineBundleUnion(const RoutineBundleUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case RoutineBundle_RoutineBytecodeBundle: {
      value = new Fx::RoutineBytecodeBundleT(*reinterpret_cast<Fx::RoutineBytecodeBundleT *>(u.value));
      break;
    }
    case RoutineBundle_RoutineGLSLBundle: {
      value = new Fx::RoutineGLSLBundleT(*reinterpret_cast<Fx::RoutineGLSLBundleT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void RoutineBundleUnion::Reset() {
  switch (type) {
    case RoutineBundle_RoutineBytecodeBundle: {
      auto ptr = reinterpret_cast<Fx::RoutineBytecodeBundleT *>(value);
      delete ptr;
      break;
    }
    case RoutineBundle_RoutineGLSLBundle: {
      auto ptr = reinterpret_cast<Fx::RoutineGLSLBundleT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = RoutineBundle_NONE;
}

inline bool VerifyBundleContent(flatbuffers::Verifier &verifier, const void *obj, BundleContent type) {
  switch (type) {
    case BundleContent_NONE: {
      return true;
    }
    case BundleContent_PartBundle: {
      auto ptr = reinterpret_cast<const Fx::PartBundle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BundleContent_MatBundle: {
      auto ptr = reinterpret_cast<const Fx::MatBundle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyBundleContentVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyBundleContent(
        verifier,  values->Get(i), types->GetEnum<BundleContent>(i))) {
      return false;
    }
  }
  return true;
}

inline void *BundleContentUnion::UnPack(const void *obj, BundleContent type, const flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case BundleContent_PartBundle: {
      auto ptr = reinterpret_cast<const Fx::PartBundle *>(obj);
      return ptr->UnPack(resolver);
    }
    case BundleContent_MatBundle: {
      auto ptr = reinterpret_cast<const Fx::MatBundle *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> BundleContentUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case BundleContent_PartBundle: {
      auto ptr = reinterpret_cast<const Fx::PartBundleT *>(value);
      return CreatePartBundle(_fbb, ptr, _rehasher).Union();
    }
    case BundleContent_MatBundle: {
      auto ptr = reinterpret_cast<const Fx::MatBundleT *>(value);
      return CreateMatBundle(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline BundleContentUnion::BundleContentUnion(const BundleContentUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case BundleContent_PartBundle: {
      value = new Fx::PartBundleT(*reinterpret_cast<Fx::PartBundleT *>(u.value));
      break;
    }
    case BundleContent_MatBundle: {
      value = new Fx::MatBundleT(*reinterpret_cast<Fx::MatBundleT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void BundleContentUnion::Reset() {
  switch (type) {
    case BundleContent_PartBundle: {
      auto ptr = reinterpret_cast<Fx::PartBundleT *>(value);
      delete ptr;
      break;
    }
    case BundleContent_MatBundle: {
      auto ptr = reinterpret_cast<Fx::MatBundleT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = BundleContent_NONE;
}

inline bool VerifyUIProperties(flatbuffers::Verifier &verifier, const void *obj, UIProperties type) {
  switch (type) {
    case UIProperties_NONE: {
      return true;
    }
    case UIProperties_UISpinner: {
      auto ptr = reinterpret_cast<const Fx::UISpinner *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UIProperties_UIFloatSpinner: {
      auto ptr = reinterpret_cast<const Fx::UIFloatSpinner *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UIProperties_UIColor: {
      auto ptr = reinterpret_cast<const Fx::UIColor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UIProperties_UIFloat: {
      auto ptr = reinterpret_cast<const Fx::UIFloat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UIProperties_UIFloat3: {
      auto ptr = reinterpret_cast<const Fx::UIFloat3 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UIProperties_UIInt: {
      auto ptr = reinterpret_cast<const Fx::UIInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UIProperties_UIUint: {
      auto ptr = reinterpret_cast<const Fx::UIUint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyUIPropertiesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyUIProperties(
        verifier,  values->Get(i), types->GetEnum<UIProperties>(i))) {
      return false;
    }
  }
  return true;
}

inline void *UIPropertiesUnion::UnPack(const void *obj, UIProperties type, const flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case UIProperties_UISpinner: {
      auto ptr = reinterpret_cast<const Fx::UISpinner *>(obj);
      return ptr->UnPack(resolver);
    }
    case UIProperties_UIFloatSpinner: {
      auto ptr = reinterpret_cast<const Fx::UIFloatSpinner *>(obj);
      return ptr->UnPack(resolver);
    }
    case UIProperties_UIColor: {
      auto ptr = reinterpret_cast<const Fx::UIColor *>(obj);
      return ptr->UnPack(resolver);
    }
    case UIProperties_UIFloat: {
      auto ptr = reinterpret_cast<const Fx::UIFloat *>(obj);
      return ptr->UnPack(resolver);
    }
    case UIProperties_UIFloat3: {
      auto ptr = reinterpret_cast<const Fx::UIFloat3 *>(obj);
      return ptr->UnPack(resolver);
    }
    case UIProperties_UIInt: {
      auto ptr = reinterpret_cast<const Fx::UIInt *>(obj);
      return ptr->UnPack(resolver);
    }
    case UIProperties_UIUint: {
      auto ptr = reinterpret_cast<const Fx::UIUint *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> UIPropertiesUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case UIProperties_UISpinner: {
      auto ptr = reinterpret_cast<const Fx::UISpinnerT *>(value);
      return CreateUISpinner(_fbb, ptr, _rehasher).Union();
    }
    case UIProperties_UIFloatSpinner: {
      auto ptr = reinterpret_cast<const Fx::UIFloatSpinnerT *>(value);
      return CreateUIFloatSpinner(_fbb, ptr, _rehasher).Union();
    }
    case UIProperties_UIColor: {
      auto ptr = reinterpret_cast<const Fx::UIColorT *>(value);
      return CreateUIColor(_fbb, ptr, _rehasher).Union();
    }
    case UIProperties_UIFloat: {
      auto ptr = reinterpret_cast<const Fx::UIFloatT *>(value);
      return CreateUIFloat(_fbb, ptr, _rehasher).Union();
    }
    case UIProperties_UIFloat3: {
      auto ptr = reinterpret_cast<const Fx::UIFloat3T *>(value);
      return CreateUIFloat3(_fbb, ptr, _rehasher).Union();
    }
    case UIProperties_UIInt: {
      auto ptr = reinterpret_cast<const Fx::UIIntT *>(value);
      return CreateUIInt(_fbb, ptr, _rehasher).Union();
    }
    case UIProperties_UIUint: {
      auto ptr = reinterpret_cast<const Fx::UIUintT *>(value);
      return CreateUIUint(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline UIPropertiesUnion::UIPropertiesUnion(const UIPropertiesUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case UIProperties_UISpinner: {
      value = new Fx::UISpinnerT(*reinterpret_cast<Fx::UISpinnerT *>(u.value));
      break;
    }
    case UIProperties_UIFloatSpinner: {
      value = new Fx::UIFloatSpinnerT(*reinterpret_cast<Fx::UIFloatSpinnerT *>(u.value));
      break;
    }
    case UIProperties_UIColor: {
      value = new Fx::UIColorT(*reinterpret_cast<Fx::UIColorT *>(u.value));
      break;
    }
    case UIProperties_UIFloat: {
      value = new Fx::UIFloatT(*reinterpret_cast<Fx::UIFloatT *>(u.value));
      break;
    }
    case UIProperties_UIFloat3: {
      value = new Fx::UIFloat3T(*reinterpret_cast<Fx::UIFloat3T *>(u.value));
      break;
    }
    case UIProperties_UIInt: {
      value = new Fx::UIIntT(*reinterpret_cast<Fx::UIIntT *>(u.value));
      break;
    }
    case UIProperties_UIUint: {
      value = new Fx::UIUintT(*reinterpret_cast<Fx::UIUintT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void UIPropertiesUnion::Reset() {
  switch (type) {
    case UIProperties_UISpinner: {
      auto ptr = reinterpret_cast<Fx::UISpinnerT *>(value);
      delete ptr;
      break;
    }
    case UIProperties_UIFloatSpinner: {
      auto ptr = reinterpret_cast<Fx::UIFloatSpinnerT *>(value);
      delete ptr;
      break;
    }
    case UIProperties_UIColor: {
      auto ptr = reinterpret_cast<Fx::UIColorT *>(value);
      delete ptr;
      break;
    }
    case UIProperties_UIFloat: {
      auto ptr = reinterpret_cast<Fx::UIFloatT *>(value);
      delete ptr;
      break;
    }
    case UIProperties_UIFloat3: {
      auto ptr = reinterpret_cast<Fx::UIFloat3T *>(value);
      delete ptr;
      break;
    }
    case UIProperties_UIInt: {
      auto ptr = reinterpret_cast<Fx::UIIntT *>(value);
      delete ptr;
      break;
    }
    case UIProperties_UIUint: {
      auto ptr = reinterpret_cast<Fx::UIUintT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = UIProperties_NONE;
}

inline const Fx::Bundle *GetBundle(const void *buf) {
  return flatbuffers::GetRoot<Fx::Bundle>(buf);
}

inline const Fx::Bundle *GetSizePrefixedBundle(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Fx::Bundle>(buf);
}

inline bool VerifyBundleBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Fx::Bundle>(nullptr);
}

inline bool VerifySizePrefixedBundleBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Fx::Bundle>(nullptr);
}

inline void FinishBundleBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Fx::Bundle> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedBundleBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Fx::Bundle> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<Fx::BundleT> UnPackBundle(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Fx::BundleT>(GetBundle(buf)->UnPack(res));
}

inline std::unique_ptr<Fx::BundleT> UnPackSizePrefixedBundle(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Fx::BundleT>(GetSizePrefixedBundle(buf)->UnPack(res));
}

}  // namespace Fx

#endif  // FLATBUFFERS_GENERATED_FXBUNDLE_FX_H_
