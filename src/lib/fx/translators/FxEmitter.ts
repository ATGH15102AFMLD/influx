import { EInstructionTypes, ICompileExprInstruction, IInstruction } from "@lib/idl/IInstruction";
import { EPartFxPassGeometry, IPartFxInstruction, IPartFxPassInstruction } from "@lib/idl/part/IPartFx";

import { CodeEmitter } from "./CodeEmitter";

export class FxEmitter extends CodeEmitter {

    private emitRoutineProperty(name: string, routine: ICompileExprInstruction) {
        this.emitKeyword(name);
        this.emitKeyword('=');
        this.emitCompile(routine);
        this.emitChar(';');
        this.emitNewline();
    }

    private emitBoolProperty(name: string, val: boolean) {
        this.emitKeyword(name),
        this.emitKeyword('='),
        this.emitKeyword(String(val)),
        this.emitChar(';'),
        this.emitNewline()
    }

    private emitNumberProperty(name: string, val: number) {
        this.emitKeyword(name),
        this.emitKeyword('='),
        this.emitKeyword(String(val)),
        this.emitChar(';'),
        this.emitNewline()
    }

    private emitIdProperty(name: string, id: string) {
        this.emitKeyword(name),
        this.emitKeyword('='),
        this.emitKeyword(id),
        this.emitChar(';'),
        this.emitNewline()
    }

    emitPartFxDecl(fx: IPartFxInstruction) {
        this.begin();
        {
            this.emitKeyword('partFx');
            fx.name && this.emitKeyword(fx.name);
            fx.semantic && this.emitSemantic(fx.semantic);
            fx.annotation && this.emitAnnotation(fx.annotation);
            this.emitNewline();
            this.emitChar('{');
            this.push();
            {
                fx.capacity && this.emitNumberProperty('Capacity', fx.capacity);

                fx.spawnRoutine && this.emitRoutineProperty('SpawnRoutine', fx.spawnRoutine);
                fx.initRoutine && this.emitRoutineProperty('InitRoutine', fx.initRoutine);
                fx.updateRoutine && this.emitRoutineProperty('UpdateRoutine', fx.updateRoutine);

                this.emitNewline();
                fx.passList.forEach((pass, i) => (this.emitPartFxPass(pass), 
                    i !== fx.passList.length - 1 && this.emitNewline()));
            }
            this.pop();
            this.emitChar('}');
        }
        this.end();
    }


    emitPartFxPass(pass: IPartFxPassInstruction) {
        this.emitKeyword('pass');
        pass.name && this.emitKeyword(pass.name);
        this.emitNewline();
        this.emitChar('{');
        this.push();
        {
            pass.prerenderRoutine && this.emitRoutineProperty('PrerenderRoutine', pass.prerenderRoutine);
            pass.sorting && this.emitBoolProperty('Sorting', pass.sorting);
            this.emitIdProperty('Geometry', EPartFxPassGeometry[pass.geometry].substr(2));
            pass.instanceCount !== 1 && this.emitNumberProperty('InstanceCount', pass.instanceCount);

            super.emitPassBody(pass);
        }
        this.pop();
        this.emitChar('}');
        this.emitNewline();
    }


    emit(instr: IInstruction): CodeEmitter {
        if (!instr) {
            return this;
        }

        switch (instr.instructionType) {
            case EInstructionTypes.k_PartFxDeclInstruction:
                this.emitPartFxDecl(instr as IPartFxInstruction);
                break;
            case EInstructionTypes.k_PartFxPassInstruction:
                this.emitPartFxPass(instr as IPartFxPassInstruction);
                break;
            default:
                super.emit(instr)
        }

        return this;
    }


    // emnitPartFx(partFx: IPartFxInstruction) {
    //     this.begin();
    //     this.emitComment('ATTENTION: This file is autogenerated.\nDo not change it directly.');
    //     this.end();
    //     //partFx.particle
    // }
}


export function translate(fx: IInstruction): string {
    const emitter = new FxEmitter();
    emitter.emit(fx);
    return emitter.toString();
}

